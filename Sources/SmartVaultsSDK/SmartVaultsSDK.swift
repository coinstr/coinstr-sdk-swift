// This file was autogenerated by some hot garbage in the `uniffi` crate.
// Trust me, you don't want to mess with it!
import Foundation

// Depending on the consumer's build setup, the low-level FFI code
// might be in a separate module, or it might be compiled inline into
// this module. This is a bit of light hackery to work with both.
#if canImport(smartvaults_sdkFFI)
import smartvaults_sdkFFI
#endif

fileprivate extension RustBuffer {
    // Allocate a new buffer, copying the contents of a `UInt8` array.
    init(bytes: [UInt8]) {
        let rbuf = bytes.withUnsafeBufferPointer { ptr in
            RustBuffer.from(ptr)
        }
        self.init(capacity: rbuf.capacity, len: rbuf.len, data: rbuf.data)
    }

    static func from(_ ptr: UnsafeBufferPointer<UInt8>) -> RustBuffer {
        try! rustCall { ffi_smartvaults_sdk_ffi_rustbuffer_from_bytes(ForeignBytes(bufferPointer: ptr), $0) }
    }

    // Frees the buffer in place.
    // The buffer must not be used after this is called.
    func deallocate() {
        try! rustCall { ffi_smartvaults_sdk_ffi_rustbuffer_free(self, $0) }
    }
}

fileprivate extension ForeignBytes {
    init(bufferPointer: UnsafeBufferPointer<UInt8>) {
        self.init(len: Int32(bufferPointer.count), data: bufferPointer.baseAddress)
    }
}

// For every type used in the interface, we provide helper methods for conveniently
// lifting and lowering that type from C-compatible data, and for reading and writing
// values of that type in a buffer.

// Helper classes/extensions that don't change.
// Someday, this will be in a library of its own.

fileprivate extension Data {
    init(rustBuffer: RustBuffer) {
        // TODO: This copies the buffer. Can we read directly from a
        // Rust buffer?
        self.init(bytes: rustBuffer.data!, count: Int(rustBuffer.len))
    }
}

// Define reader functionality.  Normally this would be defined in a class or
// struct, but we use standalone functions instead in order to make external
// types work.
//
// With external types, one swift source file needs to be able to call the read
// method on another source file's FfiConverter, but then what visibility
// should Reader have?
// - If Reader is fileprivate, then this means the read() must also
//   be fileprivate, which doesn't work with external types.
// - If Reader is internal/public, we'll get compile errors since both source
//   files will try define the same type.
//
// Instead, the read() method and these helper functions input a tuple of data

fileprivate func createReader(data: Data) -> (data: Data, offset: Data.Index) {
    (data: data, offset: 0)
}

// Reads an integer at the current offset, in big-endian order, and advances
// the offset on success. Throws if reading the integer would move the
// offset past the end of the buffer.
fileprivate func readInt<T: FixedWidthInteger>(_ reader: inout (data: Data, offset: Data.Index)) throws -> T {
    let range = reader.offset..<reader.offset + MemoryLayout<T>.size
    guard reader.data.count >= range.upperBound else {
        throw UniffiInternalError.bufferOverflow
    }
    if T.self == UInt8.self {
        let value = reader.data[reader.offset]
        reader.offset += 1
        return value as! T
    }
    var value: T = 0
    let _ = withUnsafeMutableBytes(of: &value, { reader.data.copyBytes(to: $0, from: range)})
    reader.offset = range.upperBound
    return value.bigEndian
}

// Reads an arbitrary number of bytes, to be used to read
// raw bytes, this is useful when lifting strings
fileprivate func readBytes(_ reader: inout (data: Data, offset: Data.Index), count: Int) throws -> Array<UInt8> {
    let range = reader.offset..<(reader.offset+count)
    guard reader.data.count >= range.upperBound else {
        throw UniffiInternalError.bufferOverflow
    }
    var value = [UInt8](repeating: 0, count: count)
    value.withUnsafeMutableBufferPointer({ buffer in
        reader.data.copyBytes(to: buffer, from: range)
    })
    reader.offset = range.upperBound
    return value
}

// Reads a float at the current offset.
fileprivate func readFloat(_ reader: inout (data: Data, offset: Data.Index)) throws -> Float {
    return Float(bitPattern: try readInt(&reader))
}

// Reads a float at the current offset.
fileprivate func readDouble(_ reader: inout (data: Data, offset: Data.Index)) throws -> Double {
    return Double(bitPattern: try readInt(&reader))
}

// Indicates if the offset has reached the end of the buffer.
fileprivate func hasRemaining(_ reader: (data: Data, offset: Data.Index)) -> Bool {
    return reader.offset < reader.data.count
}

// Define writer functionality.  Normally this would be defined in a class or
// struct, but we use standalone functions instead in order to make external
// types work.  See the above discussion on Readers for details.

fileprivate func createWriter() -> [UInt8] {
    return []
}

fileprivate func writeBytes<S>(_ writer: inout [UInt8], _ byteArr: S) where S: Sequence, S.Element == UInt8 {
    writer.append(contentsOf: byteArr)
}

// Writes an integer in big-endian order.
//
// Warning: make sure what you are trying to write
// is in the correct type!
fileprivate func writeInt<T: FixedWidthInteger>(_ writer: inout [UInt8], _ value: T) {
    var value = value.bigEndian
    withUnsafeBytes(of: &value) { writer.append(contentsOf: $0) }
}

fileprivate func writeFloat(_ writer: inout [UInt8], _ value: Float) {
    writeInt(&writer, value.bitPattern)
}

fileprivate func writeDouble(_ writer: inout [UInt8], _ value: Double) {
    writeInt(&writer, value.bitPattern)
}

// Protocol for types that transfer other types across the FFI. This is
// analogous go the Rust trait of the same name.
fileprivate protocol FfiConverter {
    associatedtype FfiType
    associatedtype SwiftType

    static func lift(_ value: FfiType) throws -> SwiftType
    static func lower(_ value: SwiftType) -> FfiType
    static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType
    static func write(_ value: SwiftType, into buf: inout [UInt8])
}

// Types conforming to `Primitive` pass themselves directly over the FFI.
fileprivate protocol FfiConverterPrimitive: FfiConverter where FfiType == SwiftType { }

extension FfiConverterPrimitive {
    public static func lift(_ value: FfiType) throws -> SwiftType {
        return value
    }

    public static func lower(_ value: SwiftType) -> FfiType {
        return value
    }
}

// Types conforming to `FfiConverterRustBuffer` lift and lower into a `RustBuffer`.
// Used for complex types where it's hard to write a custom lift/lower.
fileprivate protocol FfiConverterRustBuffer: FfiConverter where FfiType == RustBuffer {}

extension FfiConverterRustBuffer {
    public static func lift(_ buf: RustBuffer) throws -> SwiftType {
        var reader = createReader(data: Data(rustBuffer: buf))
        let value = try read(from: &reader)
        if hasRemaining(reader) {
            throw UniffiInternalError.incompleteData
        }
        buf.deallocate()
        return value
    }

    public static func lower(_ value: SwiftType) -> RustBuffer {
          var writer = createWriter()
          write(value, into: &writer)
          return RustBuffer(bytes: writer)
    }
}
// An error type for FFI errors. These errors occur at the UniFFI level, not
// the library level.
fileprivate enum UniffiInternalError: LocalizedError {
    case bufferOverflow
    case incompleteData
    case unexpectedOptionalTag
    case unexpectedEnumCase
    case unexpectedNullPointer
    case unexpectedRustCallStatusCode
    case unexpectedRustCallError
    case unexpectedStaleHandle
    case rustPanic(_ message: String)

    public var errorDescription: String? {
        switch self {
        case .bufferOverflow: return "Reading the requested value would read past the end of the buffer"
        case .incompleteData: return "The buffer still has data after lifting its containing value"
        case .unexpectedOptionalTag: return "Unexpected optional tag; should be 0 or 1"
        case .unexpectedEnumCase: return "Raw enum value doesn't match any cases"
        case .unexpectedNullPointer: return "Raw pointer value was null"
        case .unexpectedRustCallStatusCode: return "Unexpected RustCallStatus code"
        case .unexpectedRustCallError: return "CALL_ERROR but no errorClass specified"
        case .unexpectedStaleHandle: return "The object in the handle map has been dropped already"
        case let .rustPanic(message): return message
        }
    }
}

fileprivate let CALL_SUCCESS: Int8 = 0
fileprivate let CALL_ERROR: Int8 = 1
fileprivate let CALL_PANIC: Int8 = 2
fileprivate let CALL_CANCELLED: Int8 = 3

fileprivate extension RustCallStatus {
    init() {
        self.init(
            code: CALL_SUCCESS,
            errorBuf: RustBuffer.init(
                capacity: 0,
                len: 0,
                data: nil
            )
        )
    }
}

private func rustCall<T>(_ callback: (UnsafeMutablePointer<RustCallStatus>) -> T) throws -> T {
    try makeRustCall(callback, errorHandler: nil)
}

private func rustCallWithError<T>(
    _ errorHandler: @escaping (RustBuffer) throws -> Error,
    _ callback: (UnsafeMutablePointer<RustCallStatus>) -> T) throws -> T {
    try makeRustCall(callback, errorHandler: errorHandler)
}

private func makeRustCall<T>(
    _ callback: (UnsafeMutablePointer<RustCallStatus>) -> T,
    errorHandler: ((RustBuffer) throws -> Error)?
) throws -> T {
    uniffiEnsureInitialized()
    var callStatus = RustCallStatus.init()
    let returnedVal = callback(&callStatus)
    try uniffiCheckCallStatus(callStatus: callStatus, errorHandler: errorHandler)
    return returnedVal
}

private func uniffiCheckCallStatus(
    callStatus: RustCallStatus,
    errorHandler: ((RustBuffer) throws -> Error)?
) throws {
    switch callStatus.code {
        case CALL_SUCCESS:
            return

        case CALL_ERROR:
            if let errorHandler = errorHandler {
                throw try errorHandler(callStatus.errorBuf)
            } else {
                callStatus.errorBuf.deallocate()
                throw UniffiInternalError.unexpectedRustCallError
            }

        case CALL_PANIC:
            // When the rust code sees a panic, it tries to construct a RustBuffer
            // with the message.  But if that code panics, then it just sends back
            // an empty buffer.
            if callStatus.errorBuf.len > 0 {
                throw UniffiInternalError.rustPanic(try FfiConverterString.lift(callStatus.errorBuf))
            } else {
                callStatus.errorBuf.deallocate()
                throw UniffiInternalError.rustPanic("Rust panic")
            }

        case CALL_CANCELLED:
            fatalError("Cancellation not supported yet")

        default:
            throw UniffiInternalError.unexpectedRustCallStatusCode
    }
}

// Public interface members begin here.


fileprivate struct FfiConverterUInt8: FfiConverterPrimitive {
    typealias FfiType = UInt8
    typealias SwiftType = UInt8

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt8 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: UInt8, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

fileprivate struct FfiConverterUInt16: FfiConverterPrimitive {
    typealias FfiType = UInt16
    typealias SwiftType = UInt16

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt16 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

fileprivate struct FfiConverterUInt32: FfiConverterPrimitive {
    typealias FfiType = UInt32
    typealias SwiftType = UInt32

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt32 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

fileprivate struct FfiConverterInt32: FfiConverterPrimitive {
    typealias FfiType = Int32
    typealias SwiftType = Int32

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Int32 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: Int32, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

fileprivate struct FfiConverterUInt64: FfiConverterPrimitive {
    typealias FfiType = UInt64
    typealias SwiftType = UInt64

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt64 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

fileprivate struct FfiConverterInt64: FfiConverterPrimitive {
    typealias FfiType = Int64
    typealias SwiftType = Int64

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Int64 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: Int64, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

fileprivate struct FfiConverterBool : FfiConverter {
    typealias FfiType = Int8
    typealias SwiftType = Bool

    public static func lift(_ value: Int8) throws -> Bool {
        return value != 0
    }

    public static func lower(_ value: Bool) -> Int8 {
        return value ? 1 : 0
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Bool {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: Bool, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

fileprivate struct FfiConverterString: FfiConverter {
    typealias SwiftType = String
    typealias FfiType = RustBuffer

    public static func lift(_ value: RustBuffer) throws -> String {
        defer {
            value.deallocate()
        }
        if value.data == nil {
            return String()
        }
        let bytes = UnsafeBufferPointer<UInt8>(start: value.data!, count: Int(value.len))
        return String(bytes: bytes, encoding: String.Encoding.utf8)!
    }

    public static func lower(_ value: String) -> RustBuffer {
        return value.utf8CString.withUnsafeBufferPointer { ptr in
            // The swift string gives us int8_t, we want uint8_t.
            ptr.withMemoryRebound(to: UInt8.self) { ptr in
                // The swift string gives us a trailing null byte, we don't want it.
                let buf = UnsafeBufferPointer(rebasing: ptr.prefix(upTo: ptr.count - 1))
                return RustBuffer.from(buf)
            }
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> String {
        let len: Int32 = try readInt(&buf)
        return String(bytes: try readBytes(&buf, count: Int(len)), encoding: String.Encoding.utf8)!
    }

    public static func write(_ value: String, into buf: inout [UInt8]) {
        let len = Int32(value.utf8.count)
        writeInt(&buf, len)
        writeBytes(&buf, value.utf8)
    }
}

fileprivate struct FfiConverterDuration: FfiConverterRustBuffer {
    typealias SwiftType = TimeInterval

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TimeInterval {
        let seconds: UInt64 = try readInt(&buf)
        let nanoseconds: UInt32 = try readInt(&buf)
        return Double(seconds) + (Double(nanoseconds) / 1.0e9)
    }

    public static func write(_ value: TimeInterval, into buf: inout [UInt8]) {
        if value.rounded(.down) > Double(Int64.max) {
            fatalError("Duration overflow, exceeds max bounds supported by Uniffi")
        }

        if value < 0 {
            fatalError("Invalid duration, must be non-negative")
        }

        let seconds = UInt64(value)
        let nanoseconds = UInt32((value - Double(seconds)) * 1.0e9)
        writeInt(&buf, seconds)
        writeInt(&buf, nanoseconds)
    }
}




public protocol AbortHandleProtocol : AnyObject {
    
    /**
     * Abort thread
     */
    func abort() 
    
    /**
     * Check if thread is aborted
     */
    func isAborted()  -> Bool
    
}
public class AbortHandle:
    AbortHandleProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_smartvaults_sdk_ffi_fn_clone_aborthandle(self.pointer, $0) }
    }

    deinit {
        try! rustCall { uniffi_smartvaults_sdk_ffi_fn_free_aborthandle(pointer, $0) }
    }

    

    
    
    /**
     * Abort thread
     */
    public func abort()  {
        try! 
    rustCall() {
    
    uniffi_smartvaults_sdk_ffi_fn_method_aborthandle_abort(self.uniffiClonePointer(), $0
    )
}
    }
    /**
     * Check if thread is aborted
     */
    public func isAborted()  -> Bool {
        return try!  FfiConverterBool.lift(
            try! 
    rustCall() {
    
    uniffi_smartvaults_sdk_ffi_fn_method_aborthandle_is_aborted(self.uniffiClonePointer(), $0
    )
}
        )
    }

}

public struct FfiConverterTypeAbortHandle: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = AbortHandle

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> AbortHandle {
        return AbortHandle(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: AbortHandle) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AbortHandle {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: AbortHandle, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


public func FfiConverterTypeAbortHandle_lift(_ pointer: UnsafeMutableRawPointer) throws -> AbortHandle {
    return try FfiConverterTypeAbortHandle.lift(pointer)
}

public func FfiConverterTypeAbortHandle_lower(_ value: AbortHandle) -> UnsafeMutableRawPointer {
    return FfiConverterTypeAbortHandle.lower(value)
}




public protocol AbsoluteLockTimeProtocol : AnyObject {
    
}
public class AbsoluteLockTime:
    AbsoluteLockTimeProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_smartvaults_sdk_ffi_fn_clone_absolutelocktime(self.pointer, $0) }
    }

    deinit {
        try! rustCall { uniffi_smartvaults_sdk_ffi_fn_free_absolutelocktime(pointer, $0) }
    }

    
    public static func fromHeight(height: UInt32) throws  -> AbsoluteLockTime {
        return AbsoluteLockTime(unsafeFromRawPointer: try rustCallWithError(FfiConverterTypeSmartVaultsError.lift) {
    uniffi_smartvaults_sdk_ffi_fn_constructor_absolutelocktime_from_height(
        FfiConverterUInt32.lower(height),$0)
})
    }

    
    public static func fromTimestamp(timestamp: UInt32) throws  -> AbsoluteLockTime {
        return AbsoluteLockTime(unsafeFromRawPointer: try rustCallWithError(FfiConverterTypeSmartVaultsError.lift) {
    uniffi_smartvaults_sdk_ffi_fn_constructor_absolutelocktime_from_timestamp(
        FfiConverterUInt32.lower(timestamp),$0)
})
    }

    

    
    

}

public struct FfiConverterTypeAbsoluteLockTime: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = AbsoluteLockTime

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> AbsoluteLockTime {
        return AbsoluteLockTime(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: AbsoluteLockTime) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AbsoluteLockTime {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: AbsoluteLockTime, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


public func FfiConverterTypeAbsoluteLockTime_lift(_ pointer: UnsafeMutableRawPointer) throws -> AbsoluteLockTime {
    return try FfiConverterTypeAbsoluteLockTime.lift(pointer)
}

public func FfiConverterTypeAbsoluteLockTime_lower(_ value: AbsoluteLockTime) -> UnsafeMutableRawPointer {
    return FfiConverterTypeAbsoluteLockTime.lower(value)
}




public protocol AmountProtocol : AnyObject {
    
}
public class Amount:
    AmountProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_smartvaults_sdk_ffi_fn_clone_amount(self.pointer, $0) }
    }

    deinit {
        try! rustCall { uniffi_smartvaults_sdk_ffi_fn_free_amount(pointer, $0) }
    }

    
    public static func custom(amount: UInt64)  -> Amount {
        return Amount(unsafeFromRawPointer: try! rustCall() {
    uniffi_smartvaults_sdk_ffi_fn_constructor_amount_custom(
        FfiConverterUInt64.lower(amount),$0)
})
    }

    
    public static func max()  -> Amount {
        return Amount(unsafeFromRawPointer: try! rustCall() {
    uniffi_smartvaults_sdk_ffi_fn_constructor_amount_max($0)
})
    }

    

    
    

}

public struct FfiConverterTypeAmount: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = Amount

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Amount {
        return Amount(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: Amount) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Amount {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: Amount, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


public func FfiConverterTypeAmount_lift(_ pointer: UnsafeMutableRawPointer) throws -> Amount {
    return try FfiConverterTypeAmount.lift(pointer)
}

public func FfiConverterTypeAmount_lower(_ value: Amount) -> UnsafeMutableRawPointer {
    return FfiConverterTypeAmount.lower(value)
}




public protocol BalanceProtocol : AnyObject {
    
    /**
     * Confirmed and immediately spendable balance
     */
    func confirmed()  -> UInt64
    
    /**
     * All coinbase outputs not yet matured
     */
    func immature()  -> UInt64
    
    /**
     * Get sum of trusted_pending and confirmed coins
     */
    func spendable()  -> UInt64
    
    /**
     * Get the whole balance visible to the wallet
     */
    func total()  -> UInt64
    
    /**
     * Unconfirmed UTXOs generated by a wallet tx
     */
    func trustedPending()  -> UInt64
    
    /**
     * Unconfirmed UTXOs received from an external wallet
     */
    func untrustedPending()  -> UInt64
    
}
public class Balance:
    BalanceProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_smartvaults_sdk_ffi_fn_clone_balance(self.pointer, $0) }
    }

    deinit {
        try! rustCall { uniffi_smartvaults_sdk_ffi_fn_free_balance(pointer, $0) }
    }

    

    
    
    /**
     * Confirmed and immediately spendable balance
     */
    public func confirmed()  -> UInt64 {
        return try!  FfiConverterUInt64.lift(
            try! 
    rustCall() {
    
    uniffi_smartvaults_sdk_ffi_fn_method_balance_confirmed(self.uniffiClonePointer(), $0
    )
}
        )
    }
    /**
     * All coinbase outputs not yet matured
     */
    public func immature()  -> UInt64 {
        return try!  FfiConverterUInt64.lift(
            try! 
    rustCall() {
    
    uniffi_smartvaults_sdk_ffi_fn_method_balance_immature(self.uniffiClonePointer(), $0
    )
}
        )
    }
    /**
     * Get sum of trusted_pending and confirmed coins
     */
    public func spendable()  -> UInt64 {
        return try!  FfiConverterUInt64.lift(
            try! 
    rustCall() {
    
    uniffi_smartvaults_sdk_ffi_fn_method_balance_spendable(self.uniffiClonePointer(), $0
    )
}
        )
    }
    /**
     * Get the whole balance visible to the wallet
     */
    public func total()  -> UInt64 {
        return try!  FfiConverterUInt64.lift(
            try! 
    rustCall() {
    
    uniffi_smartvaults_sdk_ffi_fn_method_balance_total(self.uniffiClonePointer(), $0
    )
}
        )
    }
    /**
     * Unconfirmed UTXOs generated by a wallet tx
     */
    public func trustedPending()  -> UInt64 {
        return try!  FfiConverterUInt64.lift(
            try! 
    rustCall() {
    
    uniffi_smartvaults_sdk_ffi_fn_method_balance_trusted_pending(self.uniffiClonePointer(), $0
    )
}
        )
    }
    /**
     * Unconfirmed UTXOs received from an external wallet
     */
    public func untrustedPending()  -> UInt64 {
        return try!  FfiConverterUInt64.lift(
            try! 
    rustCall() {
    
    uniffi_smartvaults_sdk_ffi_fn_method_balance_untrusted_pending(self.uniffiClonePointer(), $0
    )
}
        )
    }

}

public struct FfiConverterTypeBalance: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = Balance

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Balance {
        return Balance(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: Balance) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Balance {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: Balance, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


public func FfiConverterTypeBalance_lift(_ pointer: UnsafeMutableRawPointer) throws -> Balance {
    return try FfiConverterTypeBalance.lift(pointer)
}

public func FfiConverterTypeBalance_lower(_ value: Balance) -> UnsafeMutableRawPointer {
    return FfiConverterTypeBalance.lower(value)
}




public protocol BlockTimeProtocol : AnyObject {
    
    func height()  -> UInt32
    
    func timestamp()  -> Timestamp
    
}
public class BlockTime:
    BlockTimeProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_smartvaults_sdk_ffi_fn_clone_blocktime(self.pointer, $0) }
    }

    deinit {
        try! rustCall { uniffi_smartvaults_sdk_ffi_fn_free_blocktime(pointer, $0) }
    }

    

    
    
    public func height()  -> UInt32 {
        return try!  FfiConverterUInt32.lift(
            try! 
    rustCall() {
    
    uniffi_smartvaults_sdk_ffi_fn_method_blocktime_height(self.uniffiClonePointer(), $0
    )
}
        )
    }
    public func timestamp()  -> Timestamp {
        return try!  FfiConverterTypeTimestamp_lift(
            try! 
    rustCall() {
    
    uniffi_smartvaults_sdk_ffi_fn_method_blocktime_timestamp(self.uniffiClonePointer(), $0
    )
}
        )
    }

}

public struct FfiConverterTypeBlockTime: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = BlockTime

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> BlockTime {
        return BlockTime(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: BlockTime) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> BlockTime {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: BlockTime, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


public func FfiConverterTypeBlockTime_lift(_ pointer: UnsafeMutableRawPointer) throws -> BlockTime {
    return try FfiConverterTypeBlockTime.lift(pointer)
}

public func FfiConverterTypeBlockTime_lower(_ value: BlockTime) -> UnsafeMutableRawPointer {
    return FfiConverterTypeBlockTime.lower(value)
}




public protocol ConfigProtocol : AnyObject {
    
    func blockExplorer() throws  -> String
    
    func electrumEndpoint() throws  -> String
    
    func save() throws 
    
    func setBlockExplorer(url: String) throws 
    
    func setElectrumEndpoint(endpoint: String) 
    
}
public class Config:
    ConfigProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_smartvaults_sdk_ffi_fn_clone_config(self.pointer, $0) }
    }

    deinit {
        try! rustCall { uniffi_smartvaults_sdk_ffi_fn_free_config(pointer, $0) }
    }

    

    
    
    public func blockExplorer() throws  -> String {
        return try  FfiConverterString.lift(
            try 
    rustCallWithError(FfiConverterTypeSmartVaultsError.lift) {
    uniffi_smartvaults_sdk_ffi_fn_method_config_block_explorer(self.uniffiClonePointer(), $0
    )
}
        )
    }
    public func electrumEndpoint() throws  -> String {
        return try  FfiConverterString.lift(
            try 
    rustCallWithError(FfiConverterTypeSmartVaultsError.lift) {
    uniffi_smartvaults_sdk_ffi_fn_method_config_electrum_endpoint(self.uniffiClonePointer(), $0
    )
}
        )
    }
    public func save() throws  {
        try 
    rustCallWithError(FfiConverterTypeSmartVaultsError.lift) {
    uniffi_smartvaults_sdk_ffi_fn_method_config_save(self.uniffiClonePointer(), $0
    )
}
    }
    public func setBlockExplorer(url: String) throws  {
        try 
    rustCallWithError(FfiConverterTypeSmartVaultsError.lift) {
    uniffi_smartvaults_sdk_ffi_fn_method_config_set_block_explorer(self.uniffiClonePointer(), 
        FfiConverterString.lower(url),$0
    )
}
    }
    public func setElectrumEndpoint(endpoint: String)  {
        try! 
    rustCall() {
    
    uniffi_smartvaults_sdk_ffi_fn_method_config_set_electrum_endpoint(self.uniffiClonePointer(), 
        FfiConverterString.lower(endpoint),$0
    )
}
    }

}

public struct FfiConverterTypeConfig: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = Config

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Config {
        return Config(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: Config) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Config {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: Config, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


public func FfiConverterTypeConfig_lift(_ pointer: UnsafeMutableRawPointer) throws -> Config {
    return try FfiConverterTypeConfig.lift(pointer)
}

public func FfiConverterTypeConfig_lower(_ value: Config) -> UnsafeMutableRawPointer {
    return FfiConverterTypeConfig.lower(value)
}




public protocol DecayingTimeProtocol : AnyObject {
    
}
public class DecayingTime:
    DecayingTimeProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_smartvaults_sdk_ffi_fn_clone_decayingtime(self.pointer, $0) }
    }

    deinit {
        try! rustCall { uniffi_smartvaults_sdk_ffi_fn_free_decayingtime(pointer, $0) }
    }

    
    public static func multiple(locktimes: [Locktime])  -> DecayingTime {
        return DecayingTime(unsafeFromRawPointer: try! rustCall() {
    uniffi_smartvaults_sdk_ffi_fn_constructor_decayingtime_multiple(
        FfiConverterSequenceTypeLocktime.lower(locktimes),$0)
})
    }

    
    public static func single(locktime: Locktime)  -> DecayingTime {
        return DecayingTime(unsafeFromRawPointer: try! rustCall() {
    uniffi_smartvaults_sdk_ffi_fn_constructor_decayingtime_single(
        FfiConverterTypeLocktime.lower(locktime),$0)
})
    }

    

    
    

}

public struct FfiConverterTypeDecayingTime: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = DecayingTime

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> DecayingTime {
        return DecayingTime(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: DecayingTime) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DecayingTime {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: DecayingTime, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


public func FfiConverterTypeDecayingTime_lift(_ pointer: UnsafeMutableRawPointer) throws -> DecayingTime {
    return try FfiConverterTypeDecayingTime.lift(pointer)
}

public func FfiConverterTypeDecayingTime_lower(_ value: DecayingTime) -> UnsafeMutableRawPointer {
    return FfiConverterTypeDecayingTime.lower(value)
}




public protocol DescriptorProtocol : AnyObject {
    
    func toStr()  -> String
    
}
public class Descriptor:
    DescriptorProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_smartvaults_sdk_ffi_fn_clone_descriptor(self.pointer, $0) }
    }

    deinit {
        try! rustCall { uniffi_smartvaults_sdk_ffi_fn_free_descriptor(pointer, $0) }
    }

    
    public static func parse(descriptor: String) throws  -> Descriptor {
        return Descriptor(unsafeFromRawPointer: try rustCallWithError(FfiConverterTypeSmartVaultsError.lift) {
    uniffi_smartvaults_sdk_ffi_fn_constructor_descriptor_parse(
        FfiConverterString.lower(descriptor),$0)
})
    }

    

    
    
    public func toStr()  -> String {
        return try!  FfiConverterString.lift(
            try! 
    rustCall() {
    
    uniffi_smartvaults_sdk_ffi_fn_method_descriptor_to_str(self.uniffiClonePointer(), $0
    )
}
        )
    }

}

public struct FfiConverterTypeDescriptor: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = Descriptor

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Descriptor {
        return Descriptor(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: Descriptor) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Descriptor {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: Descriptor, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


public func FfiConverterTypeDescriptor_lift(_ pointer: UnsafeMutableRawPointer) throws -> Descriptor {
    return try FfiConverterTypeDescriptor.lift(pointer)
}

public func FfiConverterTypeDescriptor_lower(_ value: Descriptor) -> UnsafeMutableRawPointer {
    return FfiConverterTypeDescriptor.lower(value)
}




public protocol GetAddressProtocol : AnyObject {
    
    func address()  -> String
    
    func label()  -> String?
    
}
public class GetAddress:
    GetAddressProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_smartvaults_sdk_ffi_fn_clone_getaddress(self.pointer, $0) }
    }

    deinit {
        try! rustCall { uniffi_smartvaults_sdk_ffi_fn_free_getaddress(pointer, $0) }
    }

    

    
    
    public func address()  -> String {
        return try!  FfiConverterString.lift(
            try! 
    rustCall() {
    
    uniffi_smartvaults_sdk_ffi_fn_method_getaddress_address(self.uniffiClonePointer(), $0
    )
}
        )
    }
    public func label()  -> String? {
        return try!  FfiConverterOptionString.lift(
            try! 
    rustCall() {
    
    uniffi_smartvaults_sdk_ffi_fn_method_getaddress_label(self.uniffiClonePointer(), $0
    )
}
        )
    }

}

public struct FfiConverterTypeGetAddress: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = GetAddress

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> GetAddress {
        return GetAddress(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: GetAddress) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> GetAddress {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: GetAddress, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


public func FfiConverterTypeGetAddress_lift(_ pointer: UnsafeMutableRawPointer) throws -> GetAddress {
    return try FfiConverterTypeGetAddress.lift(pointer)
}

public func FfiConverterTypeGetAddress_lower(_ value: GetAddress) -> UnsafeMutableRawPointer {
    return FfiConverterTypeGetAddress.lower(value)
}




public protocol GetApprovalProtocol : AnyObject {
    
    func approvalId()  -> EventId
    
    func approvedProposal()  -> ApprovedProposal
    
    func timestamp()  -> Timestamp
    
    func user()  -> Profile
    
}
public class GetApproval:
    GetApprovalProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_smartvaults_sdk_ffi_fn_clone_getapproval(self.pointer, $0) }
    }

    deinit {
        try! rustCall { uniffi_smartvaults_sdk_ffi_fn_free_getapproval(pointer, $0) }
    }

    

    
    
    public func approvalId()  -> EventId {
        return try!  FfiConverterTypeEventId_lift(
            try! 
    rustCall() {
    
    uniffi_smartvaults_sdk_ffi_fn_method_getapproval_approval_id(self.uniffiClonePointer(), $0
    )
}
        )
    }
    public func approvedProposal()  -> ApprovedProposal {
        return try!  FfiConverterTypeApprovedProposal.lift(
            try! 
    rustCall() {
    
    uniffi_smartvaults_sdk_ffi_fn_method_getapproval_approved_proposal(self.uniffiClonePointer(), $0
    )
}
        )
    }
    public func timestamp()  -> Timestamp {
        return try!  FfiConverterTypeTimestamp_lift(
            try! 
    rustCall() {
    
    uniffi_smartvaults_sdk_ffi_fn_method_getapproval_timestamp(self.uniffiClonePointer(), $0
    )
}
        )
    }
    public func user()  -> Profile {
        return try!  FfiConverterTypeProfile_lift(
            try! 
    rustCall() {
    
    uniffi_smartvaults_sdk_ffi_fn_method_getapproval_user(self.uniffiClonePointer(), $0
    )
}
        )
    }

}

public struct FfiConverterTypeGetApproval: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = GetApproval

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> GetApproval {
        return GetApproval(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: GetApproval) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> GetApproval {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: GetApproval, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


public func FfiConverterTypeGetApproval_lift(_ pointer: UnsafeMutableRawPointer) throws -> GetApproval {
    return try FfiConverterTypeGetApproval.lift(pointer)
}

public func FfiConverterTypeGetApproval_lower(_ value: GetApproval) -> UnsafeMutableRawPointer {
    return FfiConverterTypeGetApproval.lower(value)
}




public protocol GetCompletedProposalProtocol : AnyObject {
    
    func completedProposal()  -> CompletedProposal
    
    func completedProposalId()  -> EventId
    
    func policyId()  -> EventId
    
}
public class GetCompletedProposal:
    GetCompletedProposalProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_smartvaults_sdk_ffi_fn_clone_getcompletedproposal(self.pointer, $0) }
    }

    deinit {
        try! rustCall { uniffi_smartvaults_sdk_ffi_fn_free_getcompletedproposal(pointer, $0) }
    }

    

    
    
    public func completedProposal()  -> CompletedProposal {
        return try!  FfiConverterTypeCompletedProposal.lift(
            try! 
    rustCall() {
    
    uniffi_smartvaults_sdk_ffi_fn_method_getcompletedproposal_completed_proposal(self.uniffiClonePointer(), $0
    )
}
        )
    }
    public func completedProposalId()  -> EventId {
        return try!  FfiConverterTypeEventId_lift(
            try! 
    rustCall() {
    
    uniffi_smartvaults_sdk_ffi_fn_method_getcompletedproposal_completed_proposal_id(self.uniffiClonePointer(), $0
    )
}
        )
    }
    public func policyId()  -> EventId {
        return try!  FfiConverterTypeEventId_lift(
            try! 
    rustCall() {
    
    uniffi_smartvaults_sdk_ffi_fn_method_getcompletedproposal_policy_id(self.uniffiClonePointer(), $0
    )
}
        )
    }

}

public struct FfiConverterTypeGetCompletedProposal: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = GetCompletedProposal

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> GetCompletedProposal {
        return GetCompletedProposal(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: GetCompletedProposal) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> GetCompletedProposal {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: GetCompletedProposal, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


public func FfiConverterTypeGetCompletedProposal_lift(_ pointer: UnsafeMutableRawPointer) throws -> GetCompletedProposal {
    return try FfiConverterTypeGetCompletedProposal.lift(pointer)
}

public func FfiConverterTypeGetCompletedProposal_lower(_ value: GetCompletedProposal) -> UnsafeMutableRawPointer {
    return FfiConverterTypeGetCompletedProposal.lower(value)
}




public protocol GetPolicyProtocol : AnyObject {
    
    func balance()  -> Balance
    
    func lastSync()  -> Timestamp?
    
    func policy()  -> Policy
    
    func policyId()  -> EventId
    
}
public class GetPolicy:
    GetPolicyProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_smartvaults_sdk_ffi_fn_clone_getpolicy(self.pointer, $0) }
    }

    deinit {
        try! rustCall { uniffi_smartvaults_sdk_ffi_fn_free_getpolicy(pointer, $0) }
    }

    

    
    
    public func balance()  -> Balance {
        return try!  FfiConverterTypeBalance.lift(
            try! 
    rustCall() {
    
    uniffi_smartvaults_sdk_ffi_fn_method_getpolicy_balance(self.uniffiClonePointer(), $0
    )
}
        )
    }
    public func lastSync()  -> Timestamp? {
        return try!  FfiConverterOptionTypeTimestamp.lift(
            try! 
    rustCall() {
    
    uniffi_smartvaults_sdk_ffi_fn_method_getpolicy_last_sync(self.uniffiClonePointer(), $0
    )
}
        )
    }
    public func policy()  -> Policy {
        return try!  FfiConverterTypePolicy.lift(
            try! 
    rustCall() {
    
    uniffi_smartvaults_sdk_ffi_fn_method_getpolicy_policy(self.uniffiClonePointer(), $0
    )
}
        )
    }
    public func policyId()  -> EventId {
        return try!  FfiConverterTypeEventId_lift(
            try! 
    rustCall() {
    
    uniffi_smartvaults_sdk_ffi_fn_method_getpolicy_policy_id(self.uniffiClonePointer(), $0
    )
}
        )
    }

}

public struct FfiConverterTypeGetPolicy: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = GetPolicy

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> GetPolicy {
        return GetPolicy(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: GetPolicy) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> GetPolicy {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: GetPolicy, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


public func FfiConverterTypeGetPolicy_lift(_ pointer: UnsafeMutableRawPointer) throws -> GetPolicy {
    return try FfiConverterTypeGetPolicy.lift(pointer)
}

public func FfiConverterTypeGetPolicy_lower(_ value: GetPolicy) -> UnsafeMutableRawPointer {
    return FfiConverterTypeGetPolicy.lower(value)
}




public protocol GetProposalProtocol : AnyObject {
    
    func isSigned()  -> Bool
    
    func policyId()  -> EventId
    
    func proposal()  -> Proposal
    
    func proposalId()  -> EventId
    
}
public class GetProposal:
    GetProposalProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_smartvaults_sdk_ffi_fn_clone_getproposal(self.pointer, $0) }
    }

    deinit {
        try! rustCall { uniffi_smartvaults_sdk_ffi_fn_free_getproposal(pointer, $0) }
    }

    

    
    
    public func isSigned()  -> Bool {
        return try!  FfiConverterBool.lift(
            try! 
    rustCall() {
    
    uniffi_smartvaults_sdk_ffi_fn_method_getproposal_is_signed(self.uniffiClonePointer(), $0
    )
}
        )
    }
    public func policyId()  -> EventId {
        return try!  FfiConverterTypeEventId_lift(
            try! 
    rustCall() {
    
    uniffi_smartvaults_sdk_ffi_fn_method_getproposal_policy_id(self.uniffiClonePointer(), $0
    )
}
        )
    }
    public func proposal()  -> Proposal {
        return try!  FfiConverterTypeProposal.lift(
            try! 
    rustCall() {
    
    uniffi_smartvaults_sdk_ffi_fn_method_getproposal_proposal(self.uniffiClonePointer(), $0
    )
}
        )
    }
    public func proposalId()  -> EventId {
        return try!  FfiConverterTypeEventId_lift(
            try! 
    rustCall() {
    
    uniffi_smartvaults_sdk_ffi_fn_method_getproposal_proposal_id(self.uniffiClonePointer(), $0
    )
}
        )
    }

}

public struct FfiConverterTypeGetProposal: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = GetProposal

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> GetProposal {
        return GetProposal(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: GetProposal) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> GetProposal {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: GetProposal, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


public func FfiConverterTypeGetProposal_lift(_ pointer: UnsafeMutableRawPointer) throws -> GetProposal {
    return try FfiConverterTypeGetProposal.lift(pointer)
}

public func FfiConverterTypeGetProposal_lower(_ value: GetProposal) -> UnsafeMutableRawPointer {
    return FfiConverterTypeGetProposal.lower(value)
}




public protocol GetSharedSignerProtocol : AnyObject {
    
    func owner()  -> Profile
    
    func sharedSigner()  -> SharedSigner
    
    func sharedSignerId()  -> EventId
    
}
public class GetSharedSigner:
    GetSharedSignerProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_smartvaults_sdk_ffi_fn_clone_getsharedsigner(self.pointer, $0) }
    }

    deinit {
        try! rustCall { uniffi_smartvaults_sdk_ffi_fn_free_getsharedsigner(pointer, $0) }
    }

    

    
    
    public func owner()  -> Profile {
        return try!  FfiConverterTypeProfile_lift(
            try! 
    rustCall() {
    
    uniffi_smartvaults_sdk_ffi_fn_method_getsharedsigner_owner(self.uniffiClonePointer(), $0
    )
}
        )
    }
    public func sharedSigner()  -> SharedSigner {
        return try!  FfiConverterTypeSharedSigner.lift(
            try! 
    rustCall() {
    
    uniffi_smartvaults_sdk_ffi_fn_method_getsharedsigner_shared_signer(self.uniffiClonePointer(), $0
    )
}
        )
    }
    public func sharedSignerId()  -> EventId {
        return try!  FfiConverterTypeEventId_lift(
            try! 
    rustCall() {
    
    uniffi_smartvaults_sdk_ffi_fn_method_getsharedsigner_shared_signer_id(self.uniffiClonePointer(), $0
    )
}
        )
    }

}

public struct FfiConverterTypeGetSharedSigner: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = GetSharedSigner

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> GetSharedSigner {
        return GetSharedSigner(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: GetSharedSigner) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> GetSharedSigner {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: GetSharedSigner, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


public func FfiConverterTypeGetSharedSigner_lift(_ pointer: UnsafeMutableRawPointer) throws -> GetSharedSigner {
    return try FfiConverterTypeGetSharedSigner.lift(pointer)
}

public func FfiConverterTypeGetSharedSigner_lower(_ value: GetSharedSigner) -> UnsafeMutableRawPointer {
    return FfiConverterTypeGetSharedSigner.lower(value)
}




public protocol GetSignerProtocol : AnyObject {
    
    func signer()  -> Signer
    
    func signerId()  -> EventId
    
}
public class GetSigner:
    GetSignerProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_smartvaults_sdk_ffi_fn_clone_getsigner(self.pointer, $0) }
    }

    deinit {
        try! rustCall { uniffi_smartvaults_sdk_ffi_fn_free_getsigner(pointer, $0) }
    }

    

    
    
    public func signer()  -> Signer {
        return try!  FfiConverterTypeSigner.lift(
            try! 
    rustCall() {
    
    uniffi_smartvaults_sdk_ffi_fn_method_getsigner_signer(self.uniffiClonePointer(), $0
    )
}
        )
    }
    public func signerId()  -> EventId {
        return try!  FfiConverterTypeEventId_lift(
            try! 
    rustCall() {
    
    uniffi_smartvaults_sdk_ffi_fn_method_getsigner_signer_id(self.uniffiClonePointer(), $0
    )
}
        )
    }

}

public struct FfiConverterTypeGetSigner: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = GetSigner

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> GetSigner {
        return GetSigner(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: GetSigner) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> GetSigner {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: GetSigner, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


public func FfiConverterTypeGetSigner_lift(_ pointer: UnsafeMutableRawPointer) throws -> GetSigner {
    return try FfiConverterTypeGetSigner.lift(pointer)
}

public func FfiConverterTypeGetSigner_lower(_ value: GetSigner) -> UnsafeMutableRawPointer {
    return FfiConverterTypeGetSigner.lower(value)
}




public protocol GetTransactionProtocol : AnyObject {
    
    func blockExplorer()  -> String?
    
    func label()  -> String?
    
    func policyId()  -> EventId
    
    func tx()  -> TransactionDetails
    
}
public class GetTransaction:
    GetTransactionProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_smartvaults_sdk_ffi_fn_clone_gettransaction(self.pointer, $0) }
    }

    deinit {
        try! rustCall { uniffi_smartvaults_sdk_ffi_fn_free_gettransaction(pointer, $0) }
    }

    

    
    
    public func blockExplorer()  -> String? {
        return try!  FfiConverterOptionString.lift(
            try! 
    rustCall() {
    
    uniffi_smartvaults_sdk_ffi_fn_method_gettransaction_block_explorer(self.uniffiClonePointer(), $0
    )
}
        )
    }
    public func label()  -> String? {
        return try!  FfiConverterOptionString.lift(
            try! 
    rustCall() {
    
    uniffi_smartvaults_sdk_ffi_fn_method_gettransaction_label(self.uniffiClonePointer(), $0
    )
}
        )
    }
    public func policyId()  -> EventId {
        return try!  FfiConverterTypeEventId_lift(
            try! 
    rustCall() {
    
    uniffi_smartvaults_sdk_ffi_fn_method_gettransaction_policy_id(self.uniffiClonePointer(), $0
    )
}
        )
    }
    public func tx()  -> TransactionDetails {
        return try!  FfiConverterTypeTransactionDetails.lift(
            try! 
    rustCall() {
    
    uniffi_smartvaults_sdk_ffi_fn_method_gettransaction_tx(self.uniffiClonePointer(), $0
    )
}
        )
    }

}

public struct FfiConverterTypeGetTransaction: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = GetTransaction

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> GetTransaction {
        return GetTransaction(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: GetTransaction) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> GetTransaction {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: GetTransaction, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


public func FfiConverterTypeGetTransaction_lift(_ pointer: UnsafeMutableRawPointer) throws -> GetTransaction {
    return try FfiConverterTypeGetTransaction.lift(pointer)
}

public func FfiConverterTypeGetTransaction_lower(_ value: GetTransaction) -> UnsafeMutableRawPointer {
    return FfiConverterTypeGetTransaction.lower(value)
}




public protocol LocktimeProtocol : AnyObject {
    
}
public class Locktime:
    LocktimeProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_smartvaults_sdk_ffi_fn_clone_locktime(self.pointer, $0) }
    }

    deinit {
        try! rustCall { uniffi_smartvaults_sdk_ffi_fn_free_locktime(pointer, $0) }
    }

    
    public static func absolute(absolute: AbsoluteLockTime)  -> Locktime {
        return Locktime(unsafeFromRawPointer: try! rustCall() {
    uniffi_smartvaults_sdk_ffi_fn_constructor_locktime_absolute(
        FfiConverterTypeAbsoluteLockTime.lower(absolute),$0)
})
    }

    
    public static func relative(relative: RelativeLockTime)  -> Locktime {
        return Locktime(unsafeFromRawPointer: try! rustCall() {
    uniffi_smartvaults_sdk_ffi_fn_constructor_locktime_relative(
        FfiConverterTypeRelativeLockTime.lower(relative),$0)
})
    }

    

    
    

}

public struct FfiConverterTypeLocktime: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = Locktime

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Locktime {
        return Locktime(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: Locktime) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Locktime {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: Locktime, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


public func FfiConverterTypeLocktime_lift(_ pointer: UnsafeMutableRawPointer) throws -> Locktime {
    return try FfiConverterTypeLocktime.lift(pointer)
}

public func FfiConverterTypeLocktime_lower(_ value: Locktime) -> UnsafeMutableRawPointer {
    return FfiConverterTypeLocktime.lower(value)
}




public protocol NostrConnectRequestProtocol : AnyObject {
    
    func appPublicKey()  -> PublicKey
    
    func approved()  -> Bool
    
    func eventId()  -> EventId
    
    func message()  -> String
    
    func timestamp()  -> Timestamp
    
}
public class NostrConnectRequest:
    NostrConnectRequestProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_smartvaults_sdk_ffi_fn_clone_nostrconnectrequest(self.pointer, $0) }
    }

    deinit {
        try! rustCall { uniffi_smartvaults_sdk_ffi_fn_free_nostrconnectrequest(pointer, $0) }
    }

    

    
    
    public func appPublicKey()  -> PublicKey {
        return try!  FfiConverterTypePublicKey_lift(
            try! 
    rustCall() {
    
    uniffi_smartvaults_sdk_ffi_fn_method_nostrconnectrequest_app_public_key(self.uniffiClonePointer(), $0
    )
}
        )
    }
    public func approved()  -> Bool {
        return try!  FfiConverterBool.lift(
            try! 
    rustCall() {
    
    uniffi_smartvaults_sdk_ffi_fn_method_nostrconnectrequest_approved(self.uniffiClonePointer(), $0
    )
}
        )
    }
    public func eventId()  -> EventId {
        return try!  FfiConverterTypeEventId_lift(
            try! 
    rustCall() {
    
    uniffi_smartvaults_sdk_ffi_fn_method_nostrconnectrequest_event_id(self.uniffiClonePointer(), $0
    )
}
        )
    }
    public func message()  -> String {
        return try!  FfiConverterString.lift(
            try! 
    rustCall() {
    
    uniffi_smartvaults_sdk_ffi_fn_method_nostrconnectrequest_message(self.uniffiClonePointer(), $0
    )
}
        )
    }
    public func timestamp()  -> Timestamp {
        return try!  FfiConverterTypeTimestamp_lift(
            try! 
    rustCall() {
    
    uniffi_smartvaults_sdk_ffi_fn_method_nostrconnectrequest_timestamp(self.uniffiClonePointer(), $0
    )
}
        )
    }

}

public struct FfiConverterTypeNostrConnectRequest: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = NostrConnectRequest

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> NostrConnectRequest {
        return NostrConnectRequest(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: NostrConnectRequest) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NostrConnectRequest {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: NostrConnectRequest, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


public func FfiConverterTypeNostrConnectRequest_lift(_ pointer: UnsafeMutableRawPointer) throws -> NostrConnectRequest {
    return try FfiConverterTypeNostrConnectRequest.lift(pointer)
}

public func FfiConverterTypeNostrConnectRequest_lower(_ value: NostrConnectRequest) -> UnsafeMutableRawPointer {
    return FfiConverterTypeNostrConnectRequest.lower(value)
}




public protocol OutPointProtocol : AnyObject {
    
    func txid()  -> String
    
    func vout()  -> UInt32
    
}
public class OutPoint:
    OutPointProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_smartvaults_sdk_ffi_fn_clone_outpoint(self.pointer, $0) }
    }

    deinit {
        try! rustCall { uniffi_smartvaults_sdk_ffi_fn_free_outpoint(pointer, $0) }
    }

    

    
    
    public func txid()  -> String {
        return try!  FfiConverterString.lift(
            try! 
    rustCall() {
    
    uniffi_smartvaults_sdk_ffi_fn_method_outpoint_txid(self.uniffiClonePointer(), $0
    )
}
        )
    }
    public func vout()  -> UInt32 {
        return try!  FfiConverterUInt32.lift(
            try! 
    rustCall() {
    
    uniffi_smartvaults_sdk_ffi_fn_method_outpoint_vout(self.uniffiClonePointer(), $0
    )
}
        )
    }

}

public struct FfiConverterTypeOutPoint: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = OutPoint

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> OutPoint {
        return OutPoint(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: OutPoint) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> OutPoint {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: OutPoint, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


public func FfiConverterTypeOutPoint_lift(_ pointer: UnsafeMutableRawPointer) throws -> OutPoint {
    return try FfiConverterTypeOutPoint.lift(pointer)
}

public func FfiConverterTypeOutPoint_lower(_ value: OutPoint) -> UnsafeMutableRawPointer {
    return FfiConverterTypeOutPoint.lower(value)
}




public protocol PolicyProtocol : AnyObject {
    
    func description()  -> String
    
    func descriptor()  -> String
    
    func getPolicyPathFromSigner(signer: Signer) throws  -> PolicyPathSelector?
    
    func getPolicyPathsFromSigners(signers: [Signer]) throws  -> PolicyPath
    
    func hasTimelock()  -> Bool
    
    func name()  -> String
    
    func satisfiableItem() throws  -> String
    
    func searchUsedSigners(signers: [Signer]) throws  -> [Signer]
    
    func selectableConditions() throws  -> [String: [String]]?
    
    func templateMatch() throws  -> PolicyTemplateType?
    
}
public class Policy:
    PolicyProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_smartvaults_sdk_ffi_fn_clone_policy(self.pointer, $0) }
    }

    deinit {
        try! rustCall { uniffi_smartvaults_sdk_ffi_fn_free_policy(pointer, $0) }
    }

    

    
    
    public func description()  -> String {
        return try!  FfiConverterString.lift(
            try! 
    rustCall() {
    
    uniffi_smartvaults_sdk_ffi_fn_method_policy_description(self.uniffiClonePointer(), $0
    )
}
        )
    }
    public func descriptor()  -> String {
        return try!  FfiConverterString.lift(
            try! 
    rustCall() {
    
    uniffi_smartvaults_sdk_ffi_fn_method_policy_descriptor(self.uniffiClonePointer(), $0
    )
}
        )
    }
    public func getPolicyPathFromSigner(signer: Signer) throws  -> PolicyPathSelector? {
        return try  FfiConverterOptionTypePolicyPathSelector.lift(
            try 
    rustCallWithError(FfiConverterTypeSmartVaultsError.lift) {
    uniffi_smartvaults_sdk_ffi_fn_method_policy_get_policy_path_from_signer(self.uniffiClonePointer(), 
        FfiConverterTypeSigner.lower(signer),$0
    )
}
        )
    }
    public func getPolicyPathsFromSigners(signers: [Signer]) throws  -> PolicyPath {
        return try  FfiConverterTypePolicyPath.lift(
            try 
    rustCallWithError(FfiConverterTypeSmartVaultsError.lift) {
    uniffi_smartvaults_sdk_ffi_fn_method_policy_get_policy_paths_from_signers(self.uniffiClonePointer(), 
        FfiConverterSequenceTypeSigner.lower(signers),$0
    )
}
        )
    }
    public func hasTimelock()  -> Bool {
        return try!  FfiConverterBool.lift(
            try! 
    rustCall() {
    
    uniffi_smartvaults_sdk_ffi_fn_method_policy_has_timelock(self.uniffiClonePointer(), $0
    )
}
        )
    }
    public func name()  -> String {
        return try!  FfiConverterString.lift(
            try! 
    rustCall() {
    
    uniffi_smartvaults_sdk_ffi_fn_method_policy_name(self.uniffiClonePointer(), $0
    )
}
        )
    }
    public func satisfiableItem() throws  -> String {
        return try  FfiConverterString.lift(
            try 
    rustCallWithError(FfiConverterTypeSmartVaultsError.lift) {
    uniffi_smartvaults_sdk_ffi_fn_method_policy_satisfiable_item(self.uniffiClonePointer(), $0
    )
}
        )
    }
    public func searchUsedSigners(signers: [Signer]) throws  -> [Signer] {
        return try  FfiConverterSequenceTypeSigner.lift(
            try 
    rustCallWithError(FfiConverterTypeSmartVaultsError.lift) {
    uniffi_smartvaults_sdk_ffi_fn_method_policy_search_used_signers(self.uniffiClonePointer(), 
        FfiConverterSequenceTypeSigner.lower(signers),$0
    )
}
        )
    }
    public func selectableConditions() throws  -> [String: [String]]? {
        return try  FfiConverterOptionDictionaryStringSequenceString.lift(
            try 
    rustCallWithError(FfiConverterTypeSmartVaultsError.lift) {
    uniffi_smartvaults_sdk_ffi_fn_method_policy_selectable_conditions(self.uniffiClonePointer(), $0
    )
}
        )
    }
    public func templateMatch() throws  -> PolicyTemplateType? {
        return try  FfiConverterOptionTypePolicyTemplateType.lift(
            try 
    rustCallWithError(FfiConverterTypeSmartVaultsError.lift) {
    uniffi_smartvaults_sdk_ffi_fn_method_policy_template_match(self.uniffiClonePointer(), $0
    )
}
        )
    }

}

public struct FfiConverterTypePolicy: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = Policy

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Policy {
        return Policy(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: Policy) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Policy {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: Policy, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


public func FfiConverterTypePolicy_lift(_ pointer: UnsafeMutableRawPointer) throws -> Policy {
    return try FfiConverterTypePolicy.lift(pointer)
}

public func FfiConverterTypePolicy_lower(_ value: Policy) -> UnsafeMutableRawPointer {
    return FfiConverterTypePolicy.lower(value)
}




public protocol PolicyTemplateProtocol : AnyObject {
    
}
public class PolicyTemplate:
    PolicyTemplateProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_smartvaults_sdk_ffi_fn_clone_policytemplate(self.pointer, $0) }
    }

    deinit {
        try! rustCall { uniffi_smartvaults_sdk_ffi_fn_free_policytemplate(pointer, $0) }
    }

    
    public static func decaying(startThreshold: UInt64, keys: [Descriptor], time: DecayingTime)  -> PolicyTemplate {
        return PolicyTemplate(unsafeFromRawPointer: try! rustCall() {
    uniffi_smartvaults_sdk_ffi_fn_constructor_policytemplate_decaying(
        FfiConverterUInt64.lower(startThreshold),
        FfiConverterSequenceTypeDescriptor.lower(keys),
        FfiConverterTypeDecayingTime.lower(time),$0)
})
    }

    
    public static func hold(myKey: Descriptor, locktime: Locktime)  -> PolicyTemplate {
        return PolicyTemplate(unsafeFromRawPointer: try! rustCall() {
    uniffi_smartvaults_sdk_ffi_fn_constructor_policytemplate_hold(
        FfiConverterTypeDescriptor.lower(myKey),
        FfiConverterTypeLocktime.lower(locktime),$0)
})
    }

    
    public static func multisig(threshold: UInt64, keys: [Descriptor])  -> PolicyTemplate {
        return PolicyTemplate(unsafeFromRawPointer: try! rustCall() {
    uniffi_smartvaults_sdk_ffi_fn_constructor_policytemplate_multisig(
        FfiConverterUInt64.lower(threshold),
        FfiConverterSequenceTypeDescriptor.lower(keys),$0)
})
    }

    
    public static func recovery(myKey: Descriptor, recovery: RecoveryTemplate)  -> PolicyTemplate {
        return PolicyTemplate(unsafeFromRawPointer: try! rustCall() {
    uniffi_smartvaults_sdk_ffi_fn_constructor_policytemplate_recovery(
        FfiConverterTypeDescriptor.lower(myKey),
        FfiConverterTypeRecoveryTemplate.lower(recovery),$0)
})
    }

    

    
    

}

public struct FfiConverterTypePolicyTemplate: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = PolicyTemplate

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> PolicyTemplate {
        return PolicyTemplate(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: PolicyTemplate) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PolicyTemplate {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: PolicyTemplate, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


public func FfiConverterTypePolicyTemplate_lift(_ pointer: UnsafeMutableRawPointer) throws -> PolicyTemplate {
    return try FfiConverterTypePolicyTemplate.lift(pointer)
}

public func FfiConverterTypePolicyTemplate_lower(_ value: PolicyTemplate) -> UnsafeMutableRawPointer {
    return FfiConverterTypePolicyTemplate.lower(value)
}




public protocol PriceProtocol : AnyObject {
    
    func amount()  -> UInt64
    
    func currency()  -> String
    
}
public class Price:
    PriceProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_smartvaults_sdk_ffi_fn_clone_price(self.pointer, $0) }
    }
    /**
     * Compose new price
     *
     * Currency must follow ISO 4217 format (3 uppercase chars)
     */
    public convenience init(amount: UInt64, currency: String) throws  {
        self.init(unsafeFromRawPointer: try rustCallWithError(FfiConverterTypeSmartVaultsError.lift) {
    uniffi_smartvaults_sdk_ffi_fn_constructor_price_new(
        FfiConverterUInt64.lower(amount),
        FfiConverterString.lower(currency),$0)
})
    }

    deinit {
        try! rustCall { uniffi_smartvaults_sdk_ffi_fn_free_price(pointer, $0) }
    }

    

    
    
    public func amount()  -> UInt64 {
        return try!  FfiConverterUInt64.lift(
            try! 
    rustCall() {
    
    uniffi_smartvaults_sdk_ffi_fn_method_price_amount(self.uniffiClonePointer(), $0
    )
}
        )
    }
    public func currency()  -> String {
        return try!  FfiConverterString.lift(
            try! 
    rustCall() {
    
    uniffi_smartvaults_sdk_ffi_fn_method_price_currency(self.uniffiClonePointer(), $0
    )
}
        )
    }

}

public struct FfiConverterTypePrice: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = Price

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Price {
        return Price(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: Price) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Price {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: Price, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


public func FfiConverterTypePrice_lift(_ pointer: UnsafeMutableRawPointer) throws -> Price {
    return try FfiConverterTypePrice.lift(pointer)
}

public func FfiConverterTypePrice_lower(_ value: Price) -> UnsafeMutableRawPointer {
    return FfiConverterTypePrice.lower(value)
}




public protocol RecoveryTemplateProtocol : AnyObject {
    
}
public class RecoveryTemplate:
    RecoveryTemplateProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_smartvaults_sdk_ffi_fn_clone_recoverytemplate(self.pointer, $0) }
    }
    public convenience init(threshold: UInt64, keys: [Descriptor], locktime: Locktime)  {
        self.init(unsafeFromRawPointer: try! rustCall() {
    uniffi_smartvaults_sdk_ffi_fn_constructor_recoverytemplate_new(
        FfiConverterUInt64.lower(threshold),
        FfiConverterSequenceTypeDescriptor.lower(keys),
        FfiConverterTypeLocktime.lower(locktime),$0)
})
    }

    deinit {
        try! rustCall { uniffi_smartvaults_sdk_ffi_fn_free_recoverytemplate(pointer, $0) }
    }

    

    
    

}

public struct FfiConverterTypeRecoveryTemplate: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = RecoveryTemplate

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> RecoveryTemplate {
        return RecoveryTemplate(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: RecoveryTemplate) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RecoveryTemplate {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: RecoveryTemplate, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


public func FfiConverterTypeRecoveryTemplate_lift(_ pointer: UnsafeMutableRawPointer) throws -> RecoveryTemplate {
    return try FfiConverterTypeRecoveryTemplate.lift(pointer)
}

public func FfiConverterTypeRecoveryTemplate_lower(_ value: RecoveryTemplate) -> UnsafeMutableRawPointer {
    return FfiConverterTypeRecoveryTemplate.lower(value)
}




public protocol RelativeLockTimeProtocol : AnyObject {
    
}
public class RelativeLockTime:
    RelativeLockTimeProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_smartvaults_sdk_ffi_fn_clone_relativelocktime(self.pointer, $0) }
    }

    deinit {
        try! rustCall { uniffi_smartvaults_sdk_ffi_fn_free_relativelocktime(pointer, $0) }
    }

    
    public static func fromBlocks(blocks: UInt16)  -> RelativeLockTime {
        return RelativeLockTime(unsafeFromRawPointer: try! rustCall() {
    uniffi_smartvaults_sdk_ffi_fn_constructor_relativelocktime_from_blocks(
        FfiConverterUInt16.lower(blocks),$0)
})
    }

    

    
    

}

public struct FfiConverterTypeRelativeLockTime: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = RelativeLockTime

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> RelativeLockTime {
        return RelativeLockTime(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: RelativeLockTime) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RelativeLockTime {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: RelativeLockTime, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


public func FfiConverterTypeRelativeLockTime_lift(_ pointer: UnsafeMutableRawPointer) throws -> RelativeLockTime {
    return try FfiConverterTypeRelativeLockTime.lift(pointer)
}

public func FfiConverterTypeRelativeLockTime_lower(_ value: RelativeLockTime) -> UnsafeMutableRawPointer {
    return FfiConverterTypeRelativeLockTime.lower(value)
}




public protocol SeedProtocol : AnyObject {
    
    func mnemonic()  -> String
    
    func passphrase()  -> String?
    
}
public class Seed:
    SeedProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_smartvaults_sdk_ffi_fn_clone_seed(self.pointer, $0) }
    }

    deinit {
        try! rustCall { uniffi_smartvaults_sdk_ffi_fn_free_seed(pointer, $0) }
    }

    

    
    
    public func mnemonic()  -> String {
        return try!  FfiConverterString.lift(
            try! 
    rustCall() {
    
    uniffi_smartvaults_sdk_ffi_fn_method_seed_mnemonic(self.uniffiClonePointer(), $0
    )
}
        )
    }
    public func passphrase()  -> String? {
        return try!  FfiConverterOptionString.lift(
            try! 
    rustCall() {
    
    uniffi_smartvaults_sdk_ffi_fn_method_seed_passphrase(self.uniffiClonePointer(), $0
    )
}
        )
    }

}

public struct FfiConverterTypeSeed: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = Seed

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Seed {
        return Seed(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: Seed) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Seed {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: Seed, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


public func FfiConverterTypeSeed_lift(_ pointer: UnsafeMutableRawPointer) throws -> Seed {
    return try FfiConverterTypeSeed.lift(pointer)
}

public func FfiConverterTypeSeed_lower(_ value: Seed) -> UnsafeMutableRawPointer {
    return FfiConverterTypeSeed.lower(value)
}




public protocol SharedSignerProtocol : AnyObject {
    
    func descriptor() throws  -> Descriptor
    
    func fingerprint()  -> String
    
}
public class SharedSigner:
    SharedSignerProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_smartvaults_sdk_ffi_fn_clone_sharedsigner(self.pointer, $0) }
    }

    deinit {
        try! rustCall { uniffi_smartvaults_sdk_ffi_fn_free_sharedsigner(pointer, $0) }
    }

    

    
    
    public func descriptor() throws  -> Descriptor {
        return try  FfiConverterTypeDescriptor.lift(
            try 
    rustCallWithError(FfiConverterTypeSmartVaultsError.lift) {
    uniffi_smartvaults_sdk_ffi_fn_method_sharedsigner_descriptor(self.uniffiClonePointer(), $0
    )
}
        )
    }
    public func fingerprint()  -> String {
        return try!  FfiConverterString.lift(
            try! 
    rustCall() {
    
    uniffi_smartvaults_sdk_ffi_fn_method_sharedsigner_fingerprint(self.uniffiClonePointer(), $0
    )
}
        )
    }

}

public struct FfiConverterTypeSharedSigner: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = SharedSigner

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> SharedSigner {
        return SharedSigner(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: SharedSigner) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SharedSigner {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: SharedSigner, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


public func FfiConverterTypeSharedSigner_lift(_ pointer: UnsafeMutableRawPointer) throws -> SharedSigner {
    return try FfiConverterTypeSharedSigner.lift(pointer)
}

public func FfiConverterTypeSharedSigner_lower(_ value: SharedSigner) -> UnsafeMutableRawPointer {
    return FfiConverterTypeSharedSigner.lower(value)
}




public protocol SignerProtocol : AnyObject {
    
    func descriptor() throws  -> Descriptor
    
    func display()  -> String
    
    func fingerprint()  -> String
    
    func name()  -> String
    
    func signerType()  -> SignerType
    
}
public class Signer:
    SignerProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_smartvaults_sdk_ffi_fn_clone_signer(self.pointer, $0) }
    }

    deinit {
        try! rustCall { uniffi_smartvaults_sdk_ffi_fn_free_signer(pointer, $0) }
    }

    

    
    
    public func descriptor() throws  -> Descriptor {
        return try  FfiConverterTypeDescriptor.lift(
            try 
    rustCallWithError(FfiConverterTypeSmartVaultsError.lift) {
    uniffi_smartvaults_sdk_ffi_fn_method_signer_descriptor(self.uniffiClonePointer(), $0
    )
}
        )
    }
    public func display()  -> String {
        return try!  FfiConverterString.lift(
            try! 
    rustCall() {
    
    uniffi_smartvaults_sdk_ffi_fn_method_signer_display(self.uniffiClonePointer(), $0
    )
}
        )
    }
    public func fingerprint()  -> String {
        return try!  FfiConverterString.lift(
            try! 
    rustCall() {
    
    uniffi_smartvaults_sdk_ffi_fn_method_signer_fingerprint(self.uniffiClonePointer(), $0
    )
}
        )
    }
    public func name()  -> String {
        return try!  FfiConverterString.lift(
            try! 
    rustCall() {
    
    uniffi_smartvaults_sdk_ffi_fn_method_signer_name(self.uniffiClonePointer(), $0
    )
}
        )
    }
    public func signerType()  -> SignerType {
        return try!  FfiConverterTypeSignerType.lift(
            try! 
    rustCall() {
    
    uniffi_smartvaults_sdk_ffi_fn_method_signer_signer_type(self.uniffiClonePointer(), $0
    )
}
        )
    }

}

public struct FfiConverterTypeSigner: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = Signer

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Signer {
        return Signer(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: Signer) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Signer {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: Signer, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


public func FfiConverterTypeSigner_lift(_ pointer: UnsafeMutableRawPointer) throws -> Signer {
    return try FfiConverterTypeSigner.lift(pointer)
}

public func FfiConverterTypeSigner_lower(_ value: Signer) -> UnsafeMutableRawPointer {
    return FfiConverterTypeSigner.lower(value)
}




public protocol SmartVaultsProtocol : AnyObject {
    
    /**
     * Add new contact
     */
    func addContact(publicKey: PublicKey) throws 
    
    /**
     * Add new relay
     */
    func addRelay(url: String) throws 
    
    func announceKeyAgent() throws  -> EventId
    
    func approve(password: String, proposalId: EventId) throws  -> EventId
    
    func approveNostrConnectRequest(eventId: EventId) throws 
    
    func approveWithSignedPsbt(proposalId: EventId, signedPsbt: String) throws  -> EventId
    
    func autoApproveNostrConnectRequests(appPublicKey: PublicKey, duration: TimeInterval) 
    
    /**
     * Get current block height
     */
    func blockHeight()  -> UInt32
    
    /**
     * Change keychain password
     */
    func changePassword(password: String, newPassword: String, confirmPassword: String) throws 
    
    /**
     * Check keychain password
     */
    func checkPassword(password: String)  -> Bool
    
    /**
     * Delete all data from cache/database
     */
    func clearCache() throws 
    
    /**
     * Get config
     */
    func config()  -> Config
    
    func deannounceKeyAgent() throws 
    
    /**
     * Get list of default relays
     */
    func defaultRelays()  -> [String]
    
    func deleteCompletedProposalById(completedProposalId: EventId) throws 
    
    func deletePolicyById(policyId: EventId) throws 
    
    func deleteProposalById(proposalId: EventId) throws 
    
    func deleteSignerById(signerId: EventId) throws 
    
    func disconnectNostrConnectSession(appPublicKey: PublicKey) throws 
    
    func finalize(proposalId: EventId) throws  -> CompletedProposal
    
    func getAddress(policyId: EventId, index: AddressIndex) throws  -> GetAddress
    
    func getAllTxs() throws  -> [GetTransaction]
    
    func getApprovalsByProposalId(proposalId: EventId) throws  -> [GetApproval]
    
    func getBalance(policyId: EventId)  -> Balance?
    
    func getCompletedProposalById(completedProposalId: EventId) throws  -> GetCompletedProposal
    
    func getCompletedProposals() throws  -> [GetCompletedProposal]
    
    func getContacts() throws  -> [Profile]
    
    func getLastUnusedAddress(policyId: EventId) throws  -> GetAddress
    
    func getMembersOfPolicy(policyId: EventId) throws  -> [Profile]
    
    func getNostrConnectRequests(approved: Bool) throws  -> [NostrConnectRequest]
    
    func getNostrConnectSessions() throws  -> [NostrConnectSession]
    
    func getPolicies() throws  -> [GetPolicy]
    
    func getPolicyById(policyId: EventId) throws  -> GetPolicy
    
    func getProfile() throws  -> Profile
    
    func getProposalById(proposalId: EventId) throws  -> GetProposal
    
    func getProposals() throws  -> [GetProposal]
    
    func getProposalsByPolicyId(policyId: EventId) throws  -> [GetProposal]
    
    func getPublicKeyMetadata(publicKey: PublicKey) throws  -> Metadata
    
    func getSharedSigners() throws  -> [GetSharedSigner]
    
    func getSharedSignersByPublicKey(publicKey: PublicKey) throws  -> [GetSharedSigner]
    
    func getSharedSignersPublicKeys(includeContacts: Bool) throws  -> [PublicKey]
    
    func getSignerById(signerId: EventId) throws  -> Signer
    
    func getSigners()  -> [GetSigner]
    
    func getTotalBalance() throws  -> Balance
    
    func getTx(policyId: EventId, txid: String) throws  -> GetTransaction
    
    func getTxs(policyId: EventId) throws  -> [GetTransaction]
    
    func getUtxos(policyId: EventId) throws  -> [Utxo]
    
    func handleSync(handler: SyncHandler)  -> AbortHandle
    
    func keyAgentPayment(policyId: EventId, toAddress: String, amount: Amount, description: String, signerDescriptor: String, period: Period, targetBlocks: UInt8, utxos: [OutPoint]?, policyPath: [String: [UInt64]]?, skipFrozenUtxos: Bool) throws  -> GetProposal
    
    /**
     * Get list of key agents
     */
    func keyAgents() throws  -> [KeyAgent]
    
    /**
     * Get client keys
     */
    func keys()  -> Keys
    
    /**
     * Get keychain name
     */
    func name()  -> String?
    
    /**
     * Get network
     */
    func network()  -> Network
    
    func newNostrConnectSession(uri: NostrConnectUri) throws 
    
    func newProofProposal(policyId: EventId, message: String) throws  -> EventId
    
    func rebroadcastAllEvents() throws 
    
    func rejectNostrConnectRequest(eventId: EventId) throws 
    
    /**
     * Get list of current added relays
     */
    func relays()  -> [Relay]
    
    /**
     * Remove contact
     */
    func removeContact(publicKey: PublicKey) throws 
    
    /**
     * Remove relay
     */
    func removeRelay(url: String) throws 
    
    /**
     * Rename keychain
     */
    func rename(newName: String) throws 
    
    func republishSharedKeyForPolicy(policyId: EventId) throws 
    
    func requestSignersToKeyAgent(keyAgent: PublicKey) throws 
    
    func revokeAllSharedSigners() throws 
    
    func revokeApproval(approvalId: EventId) throws 
    
    func revokeSharedSigner(sharedSignerId: EventId) throws 
    
    func savePolicy(name: String, description: String, descriptor: String, publicKeys: [PublicKey]) throws  -> EventId
    
    func savePolicyFromTemplate(name: String, description: String, template: PolicyTemplate, publicKeys: [PublicKey]) throws  -> EventId
    
    func saveSmartvaultsSigner() throws  -> EventId
    
    /**
     * Get seed
     */
    func seed(password: String) throws  -> Seed
    
    func selfTransfer(fromPolicyId: EventId, toPolicyId: EventId, amount: Amount, targetBlocks: UInt8, utxos: [OutPoint]?, policyPath: [String: [UInt64]]?, skipFrozenUtxos: Bool) throws  -> GetProposal
    
    func setMetadata(metadata: Metadata) throws 
    
    func shareSigner(signerId: EventId, publicKey: PublicKey) throws  -> EventId
    
    func shareSignerToMultiplePublicKeys(signerId: EventId, publicKeys: [PublicKey]) throws 
    
    /**
     * Shutdown client
     */
    func shutdown() throws 
    
    func signerOffering(signer: Signer, offering: SignerOffering) throws  -> EventId
    
    func smartvaultsSignerExists()  -> Bool
    
    func spend(policyId: EventId, toAddress: String, amount: Amount, description: String, targetBlocks: UInt8, utxos: [OutPoint]?, policyPath: [String: [UInt64]]?, skipFrozenUtxos: Bool) throws  -> GetProposal
    
    /**
     * Restart a previously stopped client
     */
    func start() 
    
    /**
     * Stop client
     *
     * Stop all threads and connections
     */
    func stop() throws 
    
    /**
     * Permanent delete the keychain
     */
    func wipe(password: String) throws 
    
}
public class SmartVaults:
    SmartVaultsProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_smartvaults_sdk_ffi_fn_clone_smartvaults(self.pointer, $0) }
    }

    deinit {
        try! rustCall { uniffi_smartvaults_sdk_ffi_fn_free_smartvaults(pointer, $0) }
    }

    
    /**
     * Generate keychain
     */
    public static func generate(basePath: String, name: String, password: String, confirmPassword: String, wordCount: WordCount, passphrase: String?, network: Network) throws  -> SmartVaults {
        return SmartVaults(unsafeFromRawPointer: try rustCallWithError(FfiConverterTypeSmartVaultsError.lift) {
    uniffi_smartvaults_sdk_ffi_fn_constructor_smartvaults_generate(
        FfiConverterString.lower(basePath),
        FfiConverterString.lower(name),
        FfiConverterString.lower(password),
        FfiConverterString.lower(confirmPassword),
        FfiConverterTypeWordCount.lower(wordCount),
        FfiConverterOptionString.lower(passphrase),
        FfiConverterTypeNetwork.lower(network),$0)
})
    }

    
    /**
     * Open keychain
     */
    public static func `open`(basePath: String, name: String, password: String, network: Network) throws  -> SmartVaults {
        return SmartVaults(unsafeFromRawPointer: try rustCallWithError(FfiConverterTypeSmartVaultsError.lift) {
    uniffi_smartvaults_sdk_ffi_fn_constructor_smartvaults_open(
        FfiConverterString.lower(basePath),
        FfiConverterString.lower(name),
        FfiConverterString.lower(password),
        FfiConverterTypeNetwork.lower(network),$0)
})
    }

    
    /**
     * Restore keychain
     */
    public static func restore(basePath: String, name: String, password: String, confirmPassword: String, mnemonic: String, passphrase: String?, network: Network) throws  -> SmartVaults {
        return SmartVaults(unsafeFromRawPointer: try rustCallWithError(FfiConverterTypeSmartVaultsError.lift) {
    uniffi_smartvaults_sdk_ffi_fn_constructor_smartvaults_restore(
        FfiConverterString.lower(basePath),
        FfiConverterString.lower(name),
        FfiConverterString.lower(password),
        FfiConverterString.lower(confirmPassword),
        FfiConverterString.lower(mnemonic),
        FfiConverterOptionString.lower(passphrase),
        FfiConverterTypeNetwork.lower(network),$0)
})
    }

    

    
    
    /**
     * Add new contact
     */
    public func addContact(publicKey: PublicKey) throws  {
        try 
    rustCallWithError(FfiConverterTypeSmartVaultsError.lift) {
    uniffi_smartvaults_sdk_ffi_fn_method_smartvaults_add_contact(self.uniffiClonePointer(), 
        FfiConverterTypePublicKey_lower(publicKey),$0
    )
}
    }
    /**
     * Add new relay
     */
    public func addRelay(url: String) throws  {
        try 
    rustCallWithError(FfiConverterTypeSmartVaultsError.lift) {
    uniffi_smartvaults_sdk_ffi_fn_method_smartvaults_add_relay(self.uniffiClonePointer(), 
        FfiConverterString.lower(url),$0
    )
}
    }
    public func announceKeyAgent() throws  -> EventId {
        return try  FfiConverterTypeEventId_lift(
            try 
    rustCallWithError(FfiConverterTypeSmartVaultsError.lift) {
    uniffi_smartvaults_sdk_ffi_fn_method_smartvaults_announce_key_agent(self.uniffiClonePointer(), $0
    )
}
        )
    }
    public func approve(password: String, proposalId: EventId) throws  -> EventId {
        return try  FfiConverterTypeEventId_lift(
            try 
    rustCallWithError(FfiConverterTypeSmartVaultsError.lift) {
    uniffi_smartvaults_sdk_ffi_fn_method_smartvaults_approve(self.uniffiClonePointer(), 
        FfiConverterString.lower(password),
        FfiConverterTypeEventId_lower(proposalId),$0
    )
}
        )
    }
    public func approveNostrConnectRequest(eventId: EventId) throws  {
        try 
    rustCallWithError(FfiConverterTypeSmartVaultsError.lift) {
    uniffi_smartvaults_sdk_ffi_fn_method_smartvaults_approve_nostr_connect_request(self.uniffiClonePointer(), 
        FfiConverterTypeEventId_lower(eventId),$0
    )
}
    }
    public func approveWithSignedPsbt(proposalId: EventId, signedPsbt: String) throws  -> EventId {
        return try  FfiConverterTypeEventId_lift(
            try 
    rustCallWithError(FfiConverterTypeSmartVaultsError.lift) {
    uniffi_smartvaults_sdk_ffi_fn_method_smartvaults_approve_with_signed_psbt(self.uniffiClonePointer(), 
        FfiConverterTypeEventId_lower(proposalId),
        FfiConverterString.lower(signedPsbt),$0
    )
}
        )
    }
    public func autoApproveNostrConnectRequests(appPublicKey: PublicKey, duration: TimeInterval)  {
        try! 
    rustCall() {
    
    uniffi_smartvaults_sdk_ffi_fn_method_smartvaults_auto_approve_nostr_connect_requests(self.uniffiClonePointer(), 
        FfiConverterTypePublicKey_lower(appPublicKey),
        FfiConverterDuration.lower(duration),$0
    )
}
    }
    /**
     * Get current block height
     */
    public func blockHeight()  -> UInt32 {
        return try!  FfiConverterUInt32.lift(
            try! 
    rustCall() {
    
    uniffi_smartvaults_sdk_ffi_fn_method_smartvaults_block_height(self.uniffiClonePointer(), $0
    )
}
        )
    }
    /**
     * Change keychain password
     */
    public func changePassword(password: String, newPassword: String, confirmPassword: String) throws  {
        try 
    rustCallWithError(FfiConverterTypeSmartVaultsError.lift) {
    uniffi_smartvaults_sdk_ffi_fn_method_smartvaults_change_password(self.uniffiClonePointer(), 
        FfiConverterString.lower(password),
        FfiConverterString.lower(newPassword),
        FfiConverterString.lower(confirmPassword),$0
    )
}
    }
    /**
     * Check keychain password
     */
    public func checkPassword(password: String)  -> Bool {
        return try!  FfiConverterBool.lift(
            try! 
    rustCall() {
    
    uniffi_smartvaults_sdk_ffi_fn_method_smartvaults_check_password(self.uniffiClonePointer(), 
        FfiConverterString.lower(password),$0
    )
}
        )
    }
    /**
     * Delete all data from cache/database
     */
    public func clearCache() throws  {
        try 
    rustCallWithError(FfiConverterTypeSmartVaultsError.lift) {
    uniffi_smartvaults_sdk_ffi_fn_method_smartvaults_clear_cache(self.uniffiClonePointer(), $0
    )
}
    }
    /**
     * Get config
     */
    public func config()  -> Config {
        return try!  FfiConverterTypeConfig.lift(
            try! 
    rustCall() {
    
    uniffi_smartvaults_sdk_ffi_fn_method_smartvaults_config(self.uniffiClonePointer(), $0
    )
}
        )
    }
    public func deannounceKeyAgent() throws  {
        try 
    rustCallWithError(FfiConverterTypeSmartVaultsError.lift) {
    uniffi_smartvaults_sdk_ffi_fn_method_smartvaults_deannounce_key_agent(self.uniffiClonePointer(), $0
    )
}
    }
    /**
     * Get list of default relays
     */
    public func defaultRelays()  -> [String] {
        return try!  FfiConverterSequenceString.lift(
            try! 
    rustCall() {
    
    uniffi_smartvaults_sdk_ffi_fn_method_smartvaults_default_relays(self.uniffiClonePointer(), $0
    )
}
        )
    }
    public func deleteCompletedProposalById(completedProposalId: EventId) throws  {
        try 
    rustCallWithError(FfiConverterTypeSmartVaultsError.lift) {
    uniffi_smartvaults_sdk_ffi_fn_method_smartvaults_delete_completed_proposal_by_id(self.uniffiClonePointer(), 
        FfiConverterTypeEventId_lower(completedProposalId),$0
    )
}
    }
    public func deletePolicyById(policyId: EventId) throws  {
        try 
    rustCallWithError(FfiConverterTypeSmartVaultsError.lift) {
    uniffi_smartvaults_sdk_ffi_fn_method_smartvaults_delete_policy_by_id(self.uniffiClonePointer(), 
        FfiConverterTypeEventId_lower(policyId),$0
    )
}
    }
    public func deleteProposalById(proposalId: EventId) throws  {
        try 
    rustCallWithError(FfiConverterTypeSmartVaultsError.lift) {
    uniffi_smartvaults_sdk_ffi_fn_method_smartvaults_delete_proposal_by_id(self.uniffiClonePointer(), 
        FfiConverterTypeEventId_lower(proposalId),$0
    )
}
    }
    public func deleteSignerById(signerId: EventId) throws  {
        try 
    rustCallWithError(FfiConverterTypeSmartVaultsError.lift) {
    uniffi_smartvaults_sdk_ffi_fn_method_smartvaults_delete_signer_by_id(self.uniffiClonePointer(), 
        FfiConverterTypeEventId_lower(signerId),$0
    )
}
    }
    public func disconnectNostrConnectSession(appPublicKey: PublicKey) throws  {
        try 
    rustCallWithError(FfiConverterTypeSmartVaultsError.lift) {
    uniffi_smartvaults_sdk_ffi_fn_method_smartvaults_disconnect_nostr_connect_session(self.uniffiClonePointer(), 
        FfiConverterTypePublicKey_lower(appPublicKey),$0
    )
}
    }
    public func finalize(proposalId: EventId) throws  -> CompletedProposal {
        return try  FfiConverterTypeCompletedProposal.lift(
            try 
    rustCallWithError(FfiConverterTypeSmartVaultsError.lift) {
    uniffi_smartvaults_sdk_ffi_fn_method_smartvaults_finalize(self.uniffiClonePointer(), 
        FfiConverterTypeEventId_lower(proposalId),$0
    )
}
        )
    }
    public func getAddress(policyId: EventId, index: AddressIndex) throws  -> GetAddress {
        return try  FfiConverterTypeGetAddress.lift(
            try 
    rustCallWithError(FfiConverterTypeSmartVaultsError.lift) {
    uniffi_smartvaults_sdk_ffi_fn_method_smartvaults_get_address(self.uniffiClonePointer(), 
        FfiConverterTypeEventId_lower(policyId),
        FfiConverterTypeAddressIndex.lower(index),$0
    )
}
        )
    }
    public func getAllTxs() throws  -> [GetTransaction] {
        return try  FfiConverterSequenceTypeGetTransaction.lift(
            try 
    rustCallWithError(FfiConverterTypeSmartVaultsError.lift) {
    uniffi_smartvaults_sdk_ffi_fn_method_smartvaults_get_all_txs(self.uniffiClonePointer(), $0
    )
}
        )
    }
    public func getApprovalsByProposalId(proposalId: EventId) throws  -> [GetApproval] {
        return try  FfiConverterSequenceTypeGetApproval.lift(
            try 
    rustCallWithError(FfiConverterTypeSmartVaultsError.lift) {
    uniffi_smartvaults_sdk_ffi_fn_method_smartvaults_get_approvals_by_proposal_id(self.uniffiClonePointer(), 
        FfiConverterTypeEventId_lower(proposalId),$0
    )
}
        )
    }
    public func getBalance(policyId: EventId)  -> Balance? {
        return try!  FfiConverterOptionTypeBalance.lift(
            try! 
    rustCall() {
    
    uniffi_smartvaults_sdk_ffi_fn_method_smartvaults_get_balance(self.uniffiClonePointer(), 
        FfiConverterTypeEventId_lower(policyId),$0
    )
}
        )
    }
    public func getCompletedProposalById(completedProposalId: EventId) throws  -> GetCompletedProposal {
        return try  FfiConverterTypeGetCompletedProposal.lift(
            try 
    rustCallWithError(FfiConverterTypeSmartVaultsError.lift) {
    uniffi_smartvaults_sdk_ffi_fn_method_smartvaults_get_completed_proposal_by_id(self.uniffiClonePointer(), 
        FfiConverterTypeEventId_lower(completedProposalId),$0
    )
}
        )
    }
    public func getCompletedProposals() throws  -> [GetCompletedProposal] {
        return try  FfiConverterSequenceTypeGetCompletedProposal.lift(
            try 
    rustCallWithError(FfiConverterTypeSmartVaultsError.lift) {
    uniffi_smartvaults_sdk_ffi_fn_method_smartvaults_get_completed_proposals(self.uniffiClonePointer(), $0
    )
}
        )
    }
    public func getContacts() throws  -> [Profile] {
        return try  FfiConverterSequenceTypeProfile.lift(
            try 
    rustCallWithError(FfiConverterTypeSmartVaultsError.lift) {
    uniffi_smartvaults_sdk_ffi_fn_method_smartvaults_get_contacts(self.uniffiClonePointer(), $0
    )
}
        )
    }
    public func getLastUnusedAddress(policyId: EventId) throws  -> GetAddress {
        return try  FfiConverterTypeGetAddress.lift(
            try 
    rustCallWithError(FfiConverterTypeSmartVaultsError.lift) {
    uniffi_smartvaults_sdk_ffi_fn_method_smartvaults_get_last_unused_address(self.uniffiClonePointer(), 
        FfiConverterTypeEventId_lower(policyId),$0
    )
}
        )
    }
    public func getMembersOfPolicy(policyId: EventId) throws  -> [Profile] {
        return try  FfiConverterSequenceTypeProfile.lift(
            try 
    rustCallWithError(FfiConverterTypeSmartVaultsError.lift) {
    uniffi_smartvaults_sdk_ffi_fn_method_smartvaults_get_members_of_policy(self.uniffiClonePointer(), 
        FfiConverterTypeEventId_lower(policyId),$0
    )
}
        )
    }
    public func getNostrConnectRequests(approved: Bool) throws  -> [NostrConnectRequest] {
        return try  FfiConverterSequenceTypeNostrConnectRequest.lift(
            try 
    rustCallWithError(FfiConverterTypeSmartVaultsError.lift) {
    uniffi_smartvaults_sdk_ffi_fn_method_smartvaults_get_nostr_connect_requests(self.uniffiClonePointer(), 
        FfiConverterBool.lower(approved),$0
    )
}
        )
    }
    public func getNostrConnectSessions() throws  -> [NostrConnectSession] {
        return try  FfiConverterSequenceTypeNostrConnectSession.lift(
            try 
    rustCallWithError(FfiConverterTypeSmartVaultsError.lift) {
    uniffi_smartvaults_sdk_ffi_fn_method_smartvaults_get_nostr_connect_sessions(self.uniffiClonePointer(), $0
    )
}
        )
    }
    public func getPolicies() throws  -> [GetPolicy] {
        return try  FfiConverterSequenceTypeGetPolicy.lift(
            try 
    rustCallWithError(FfiConverterTypeSmartVaultsError.lift) {
    uniffi_smartvaults_sdk_ffi_fn_method_smartvaults_get_policies(self.uniffiClonePointer(), $0
    )
}
        )
    }
    public func getPolicyById(policyId: EventId) throws  -> GetPolicy {
        return try  FfiConverterTypeGetPolicy.lift(
            try 
    rustCallWithError(FfiConverterTypeSmartVaultsError.lift) {
    uniffi_smartvaults_sdk_ffi_fn_method_smartvaults_get_policy_by_id(self.uniffiClonePointer(), 
        FfiConverterTypeEventId_lower(policyId),$0
    )
}
        )
    }
    public func getProfile() throws  -> Profile {
        return try  FfiConverterTypeProfile_lift(
            try 
    rustCallWithError(FfiConverterTypeSmartVaultsError.lift) {
    uniffi_smartvaults_sdk_ffi_fn_method_smartvaults_get_profile(self.uniffiClonePointer(), $0
    )
}
        )
    }
    public func getProposalById(proposalId: EventId) throws  -> GetProposal {
        return try  FfiConverterTypeGetProposal.lift(
            try 
    rustCallWithError(FfiConverterTypeSmartVaultsError.lift) {
    uniffi_smartvaults_sdk_ffi_fn_method_smartvaults_get_proposal_by_id(self.uniffiClonePointer(), 
        FfiConverterTypeEventId_lower(proposalId),$0
    )
}
        )
    }
    public func getProposals() throws  -> [GetProposal] {
        return try  FfiConverterSequenceTypeGetProposal.lift(
            try 
    rustCallWithError(FfiConverterTypeSmartVaultsError.lift) {
    uniffi_smartvaults_sdk_ffi_fn_method_smartvaults_get_proposals(self.uniffiClonePointer(), $0
    )
}
        )
    }
    public func getProposalsByPolicyId(policyId: EventId) throws  -> [GetProposal] {
        return try  FfiConverterSequenceTypeGetProposal.lift(
            try 
    rustCallWithError(FfiConverterTypeSmartVaultsError.lift) {
    uniffi_smartvaults_sdk_ffi_fn_method_smartvaults_get_proposals_by_policy_id(self.uniffiClonePointer(), 
        FfiConverterTypeEventId_lower(policyId),$0
    )
}
        )
    }
    public func getPublicKeyMetadata(publicKey: PublicKey) throws  -> Metadata {
        return try  FfiConverterTypeMetadata_lift(
            try 
    rustCallWithError(FfiConverterTypeSmartVaultsError.lift) {
    uniffi_smartvaults_sdk_ffi_fn_method_smartvaults_get_public_key_metadata(self.uniffiClonePointer(), 
        FfiConverterTypePublicKey_lower(publicKey),$0
    )
}
        )
    }
    public func getSharedSigners() throws  -> [GetSharedSigner] {
        return try  FfiConverterSequenceTypeGetSharedSigner.lift(
            try 
    rustCallWithError(FfiConverterTypeSmartVaultsError.lift) {
    uniffi_smartvaults_sdk_ffi_fn_method_smartvaults_get_shared_signers(self.uniffiClonePointer(), $0
    )
}
        )
    }
    public func getSharedSignersByPublicKey(publicKey: PublicKey) throws  -> [GetSharedSigner] {
        return try  FfiConverterSequenceTypeGetSharedSigner.lift(
            try 
    rustCallWithError(FfiConverterTypeSmartVaultsError.lift) {
    uniffi_smartvaults_sdk_ffi_fn_method_smartvaults_get_shared_signers_by_public_key(self.uniffiClonePointer(), 
        FfiConverterTypePublicKey_lower(publicKey),$0
    )
}
        )
    }
    public func getSharedSignersPublicKeys(includeContacts: Bool) throws  -> [PublicKey] {
        return try  FfiConverterSequenceTypePublicKey.lift(
            try 
    rustCallWithError(FfiConverterTypeSmartVaultsError.lift) {
    uniffi_smartvaults_sdk_ffi_fn_method_smartvaults_get_shared_signers_public_keys(self.uniffiClonePointer(), 
        FfiConverterBool.lower(includeContacts),$0
    )
}
        )
    }
    public func getSignerById(signerId: EventId) throws  -> Signer {
        return try  FfiConverterTypeSigner.lift(
            try 
    rustCallWithError(FfiConverterTypeSmartVaultsError.lift) {
    uniffi_smartvaults_sdk_ffi_fn_method_smartvaults_get_signer_by_id(self.uniffiClonePointer(), 
        FfiConverterTypeEventId_lower(signerId),$0
    )
}
        )
    }
    public func getSigners()  -> [GetSigner] {
        return try!  FfiConverterSequenceTypeGetSigner.lift(
            try! 
    rustCall() {
    
    uniffi_smartvaults_sdk_ffi_fn_method_smartvaults_get_signers(self.uniffiClonePointer(), $0
    )
}
        )
    }
    public func getTotalBalance() throws  -> Balance {
        return try  FfiConverterTypeBalance.lift(
            try 
    rustCallWithError(FfiConverterTypeSmartVaultsError.lift) {
    uniffi_smartvaults_sdk_ffi_fn_method_smartvaults_get_total_balance(self.uniffiClonePointer(), $0
    )
}
        )
    }
    public func getTx(policyId: EventId, txid: String) throws  -> GetTransaction {
        return try  FfiConverterTypeGetTransaction.lift(
            try 
    rustCallWithError(FfiConverterTypeSmartVaultsError.lift) {
    uniffi_smartvaults_sdk_ffi_fn_method_smartvaults_get_tx(self.uniffiClonePointer(), 
        FfiConverterTypeEventId_lower(policyId),
        FfiConverterString.lower(txid),$0
    )
}
        )
    }
    public func getTxs(policyId: EventId) throws  -> [GetTransaction] {
        return try  FfiConverterSequenceTypeGetTransaction.lift(
            try 
    rustCallWithError(FfiConverterTypeSmartVaultsError.lift) {
    uniffi_smartvaults_sdk_ffi_fn_method_smartvaults_get_txs(self.uniffiClonePointer(), 
        FfiConverterTypeEventId_lower(policyId),$0
    )
}
        )
    }
    public func getUtxos(policyId: EventId) throws  -> [Utxo] {
        return try  FfiConverterSequenceTypeUtxo.lift(
            try 
    rustCallWithError(FfiConverterTypeSmartVaultsError.lift) {
    uniffi_smartvaults_sdk_ffi_fn_method_smartvaults_get_utxos(self.uniffiClonePointer(), 
        FfiConverterTypeEventId_lower(policyId),$0
    )
}
        )
    }
    public func handleSync(handler: SyncHandler)  -> AbortHandle {
        return try!  FfiConverterTypeAbortHandle.lift(
            try! 
    rustCall() {
    
    uniffi_smartvaults_sdk_ffi_fn_method_smartvaults_handle_sync(self.uniffiClonePointer(), 
        FfiConverterCallbackInterfaceSyncHandler.lower(handler),$0
    )
}
        )
    }
    public func keyAgentPayment(policyId: EventId, toAddress: String, amount: Amount, description: String, signerDescriptor: String, period: Period, targetBlocks: UInt8, utxos: [OutPoint]?, policyPath: [String: [UInt64]]?, skipFrozenUtxos: Bool) throws  -> GetProposal {
        return try  FfiConverterTypeGetProposal.lift(
            try 
    rustCallWithError(FfiConverterTypeSmartVaultsError.lift) {
    uniffi_smartvaults_sdk_ffi_fn_method_smartvaults_key_agent_payment(self.uniffiClonePointer(), 
        FfiConverterTypeEventId_lower(policyId),
        FfiConverterString.lower(toAddress),
        FfiConverterTypeAmount.lower(amount),
        FfiConverterString.lower(description),
        FfiConverterString.lower(signerDescriptor),
        FfiConverterTypePeriod.lower(period),
        FfiConverterUInt8.lower(targetBlocks),
        FfiConverterOptionSequenceTypeOutPoint.lower(utxos),
        FfiConverterOptionDictionaryStringSequenceUInt64.lower(policyPath),
        FfiConverterBool.lower(skipFrozenUtxos),$0
    )
}
        )
    }
    /**
     * Get list of key agents
     */
    public func keyAgents() throws  -> [KeyAgent] {
        return try  FfiConverterSequenceTypeKeyAgent.lift(
            try 
    rustCallWithError(FfiConverterTypeSmartVaultsError.lift) {
    uniffi_smartvaults_sdk_ffi_fn_method_smartvaults_key_agents(self.uniffiClonePointer(), $0
    )
}
        )
    }
    /**
     * Get client keys
     */
    public func keys()  -> Keys {
        return try!  FfiConverterTypeKeys_lift(
            try! 
    rustCall() {
    
    uniffi_smartvaults_sdk_ffi_fn_method_smartvaults_keys(self.uniffiClonePointer(), $0
    )
}
        )
    }
    /**
     * Get keychain name
     */
    public func name()  -> String? {
        return try!  FfiConverterOptionString.lift(
            try! 
    rustCall() {
    
    uniffi_smartvaults_sdk_ffi_fn_method_smartvaults_name(self.uniffiClonePointer(), $0
    )
}
        )
    }
    /**
     * Get network
     */
    public func network()  -> Network {
        return try!  FfiConverterTypeNetwork.lift(
            try! 
    rustCall() {
    
    uniffi_smartvaults_sdk_ffi_fn_method_smartvaults_network(self.uniffiClonePointer(), $0
    )
}
        )
    }
    public func newNostrConnectSession(uri: NostrConnectUri) throws  {
        try 
    rustCallWithError(FfiConverterTypeSmartVaultsError.lift) {
    uniffi_smartvaults_sdk_ffi_fn_method_smartvaults_new_nostr_connect_session(self.uniffiClonePointer(), 
        FfiConverterTypeNostrConnectURI_lower(uri),$0
    )
}
    }
    public func newProofProposal(policyId: EventId, message: String) throws  -> EventId {
        return try  FfiConverterTypeEventId_lift(
            try 
    rustCallWithError(FfiConverterTypeSmartVaultsError.lift) {
    uniffi_smartvaults_sdk_ffi_fn_method_smartvaults_new_proof_proposal(self.uniffiClonePointer(), 
        FfiConverterTypeEventId_lower(policyId),
        FfiConverterString.lower(message),$0
    )
}
        )
    }
    public func rebroadcastAllEvents() throws  {
        try 
    rustCallWithError(FfiConverterTypeSmartVaultsError.lift) {
    uniffi_smartvaults_sdk_ffi_fn_method_smartvaults_rebroadcast_all_events(self.uniffiClonePointer(), $0
    )
}
    }
    public func rejectNostrConnectRequest(eventId: EventId) throws  {
        try 
    rustCallWithError(FfiConverterTypeSmartVaultsError.lift) {
    uniffi_smartvaults_sdk_ffi_fn_method_smartvaults_reject_nostr_connect_request(self.uniffiClonePointer(), 
        FfiConverterTypeEventId_lower(eventId),$0
    )
}
    }
    /**
     * Get list of current added relays
     */
    public func relays()  -> [Relay] {
        return try!  FfiConverterSequenceTypeRelay.lift(
            try! 
    rustCall() {
    
    uniffi_smartvaults_sdk_ffi_fn_method_smartvaults_relays(self.uniffiClonePointer(), $0
    )
}
        )
    }
    /**
     * Remove contact
     */
    public func removeContact(publicKey: PublicKey) throws  {
        try 
    rustCallWithError(FfiConverterTypeSmartVaultsError.lift) {
    uniffi_smartvaults_sdk_ffi_fn_method_smartvaults_remove_contact(self.uniffiClonePointer(), 
        FfiConverterTypePublicKey_lower(publicKey),$0
    )
}
    }
    /**
     * Remove relay
     */
    public func removeRelay(url: String) throws  {
        try 
    rustCallWithError(FfiConverterTypeSmartVaultsError.lift) {
    uniffi_smartvaults_sdk_ffi_fn_method_smartvaults_remove_relay(self.uniffiClonePointer(), 
        FfiConverterString.lower(url),$0
    )
}
    }
    /**
     * Rename keychain
     */
    public func rename(newName: String) throws  {
        try 
    rustCallWithError(FfiConverterTypeSmartVaultsError.lift) {
    uniffi_smartvaults_sdk_ffi_fn_method_smartvaults_rename(self.uniffiClonePointer(), 
        FfiConverterString.lower(newName),$0
    )
}
    }
    public func republishSharedKeyForPolicy(policyId: EventId) throws  {
        try 
    rustCallWithError(FfiConverterTypeSmartVaultsError.lift) {
    uniffi_smartvaults_sdk_ffi_fn_method_smartvaults_republish_shared_key_for_policy(self.uniffiClonePointer(), 
        FfiConverterTypeEventId_lower(policyId),$0
    )
}
    }
    public func requestSignersToKeyAgent(keyAgent: PublicKey) throws  {
        try 
    rustCallWithError(FfiConverterTypeSmartVaultsError.lift) {
    uniffi_smartvaults_sdk_ffi_fn_method_smartvaults_request_signers_to_key_agent(self.uniffiClonePointer(), 
        FfiConverterTypePublicKey_lower(keyAgent),$0
    )
}
    }
    public func revokeAllSharedSigners() throws  {
        try 
    rustCallWithError(FfiConverterTypeSmartVaultsError.lift) {
    uniffi_smartvaults_sdk_ffi_fn_method_smartvaults_revoke_all_shared_signers(self.uniffiClonePointer(), $0
    )
}
    }
    public func revokeApproval(approvalId: EventId) throws  {
        try 
    rustCallWithError(FfiConverterTypeSmartVaultsError.lift) {
    uniffi_smartvaults_sdk_ffi_fn_method_smartvaults_revoke_approval(self.uniffiClonePointer(), 
        FfiConverterTypeEventId_lower(approvalId),$0
    )
}
    }
    public func revokeSharedSigner(sharedSignerId: EventId) throws  {
        try 
    rustCallWithError(FfiConverterTypeSmartVaultsError.lift) {
    uniffi_smartvaults_sdk_ffi_fn_method_smartvaults_revoke_shared_signer(self.uniffiClonePointer(), 
        FfiConverterTypeEventId_lower(sharedSignerId),$0
    )
}
    }
    public func savePolicy(name: String, description: String, descriptor: String, publicKeys: [PublicKey]) throws  -> EventId {
        return try  FfiConverterTypeEventId_lift(
            try 
    rustCallWithError(FfiConverterTypeSmartVaultsError.lift) {
    uniffi_smartvaults_sdk_ffi_fn_method_smartvaults_save_policy(self.uniffiClonePointer(), 
        FfiConverterString.lower(name),
        FfiConverterString.lower(description),
        FfiConverterString.lower(descriptor),
        FfiConverterSequenceTypePublicKey.lower(publicKeys),$0
    )
}
        )
    }
    public func savePolicyFromTemplate(name: String, description: String, template: PolicyTemplate, publicKeys: [PublicKey]) throws  -> EventId {
        return try  FfiConverterTypeEventId_lift(
            try 
    rustCallWithError(FfiConverterTypeSmartVaultsError.lift) {
    uniffi_smartvaults_sdk_ffi_fn_method_smartvaults_save_policy_from_template(self.uniffiClonePointer(), 
        FfiConverterString.lower(name),
        FfiConverterString.lower(description),
        FfiConverterTypePolicyTemplate.lower(template),
        FfiConverterSequenceTypePublicKey.lower(publicKeys),$0
    )
}
        )
    }
    public func saveSmartvaultsSigner() throws  -> EventId {
        return try  FfiConverterTypeEventId_lift(
            try 
    rustCallWithError(FfiConverterTypeSmartVaultsError.lift) {
    uniffi_smartvaults_sdk_ffi_fn_method_smartvaults_save_smartvaults_signer(self.uniffiClonePointer(), $0
    )
}
        )
    }
    /**
     * Get seed
     */
    public func seed(password: String) throws  -> Seed {
        return try  FfiConverterTypeSeed.lift(
            try 
    rustCallWithError(FfiConverterTypeSmartVaultsError.lift) {
    uniffi_smartvaults_sdk_ffi_fn_method_smartvaults_seed(self.uniffiClonePointer(), 
        FfiConverterString.lower(password),$0
    )
}
        )
    }
    public func selfTransfer(fromPolicyId: EventId, toPolicyId: EventId, amount: Amount, targetBlocks: UInt8, utxos: [OutPoint]?, policyPath: [String: [UInt64]]?, skipFrozenUtxos: Bool) throws  -> GetProposal {
        return try  FfiConverterTypeGetProposal.lift(
            try 
    rustCallWithError(FfiConverterTypeSmartVaultsError.lift) {
    uniffi_smartvaults_sdk_ffi_fn_method_smartvaults_self_transfer(self.uniffiClonePointer(), 
        FfiConverterTypeEventId_lower(fromPolicyId),
        FfiConverterTypeEventId_lower(toPolicyId),
        FfiConverterTypeAmount.lower(amount),
        FfiConverterUInt8.lower(targetBlocks),
        FfiConverterOptionSequenceTypeOutPoint.lower(utxos),
        FfiConverterOptionDictionaryStringSequenceUInt64.lower(policyPath),
        FfiConverterBool.lower(skipFrozenUtxos),$0
    )
}
        )
    }
    public func setMetadata(metadata: Metadata) throws  {
        try 
    rustCallWithError(FfiConverterTypeSmartVaultsError.lift) {
    uniffi_smartvaults_sdk_ffi_fn_method_smartvaults_set_metadata(self.uniffiClonePointer(), 
        FfiConverterTypeMetadata_lower(metadata),$0
    )
}
    }
    public func shareSigner(signerId: EventId, publicKey: PublicKey) throws  -> EventId {
        return try  FfiConverterTypeEventId_lift(
            try 
    rustCallWithError(FfiConverterTypeSmartVaultsError.lift) {
    uniffi_smartvaults_sdk_ffi_fn_method_smartvaults_share_signer(self.uniffiClonePointer(), 
        FfiConverterTypeEventId_lower(signerId),
        FfiConverterTypePublicKey_lower(publicKey),$0
    )
}
        )
    }
    public func shareSignerToMultiplePublicKeys(signerId: EventId, publicKeys: [PublicKey]) throws  {
        try 
    rustCallWithError(FfiConverterTypeSmartVaultsError.lift) {
    uniffi_smartvaults_sdk_ffi_fn_method_smartvaults_share_signer_to_multiple_public_keys(self.uniffiClonePointer(), 
        FfiConverterTypeEventId_lower(signerId),
        FfiConverterSequenceTypePublicKey.lower(publicKeys),$0
    )
}
    }
    /**
     * Shutdown client
     */
    public func shutdown() throws  {
        try 
    rustCallWithError(FfiConverterTypeSmartVaultsError.lift) {
    uniffi_smartvaults_sdk_ffi_fn_method_smartvaults_shutdown(self.uniffiClonePointer(), $0
    )
}
    }
    public func signerOffering(signer: Signer, offering: SignerOffering) throws  -> EventId {
        return try  FfiConverterTypeEventId_lift(
            try 
    rustCallWithError(FfiConverterTypeSmartVaultsError.lift) {
    uniffi_smartvaults_sdk_ffi_fn_method_smartvaults_signer_offering(self.uniffiClonePointer(), 
        FfiConverterTypeSigner.lower(signer),
        FfiConverterTypeSignerOffering.lower(offering),$0
    )
}
        )
    }
    public func smartvaultsSignerExists()  -> Bool {
        return try!  FfiConverterBool.lift(
            try! 
    rustCall() {
    
    uniffi_smartvaults_sdk_ffi_fn_method_smartvaults_smartvaults_signer_exists(self.uniffiClonePointer(), $0
    )
}
        )
    }
    public func spend(policyId: EventId, toAddress: String, amount: Amount, description: String, targetBlocks: UInt8, utxos: [OutPoint]?, policyPath: [String: [UInt64]]?, skipFrozenUtxos: Bool) throws  -> GetProposal {
        return try  FfiConverterTypeGetProposal.lift(
            try 
    rustCallWithError(FfiConverterTypeSmartVaultsError.lift) {
    uniffi_smartvaults_sdk_ffi_fn_method_smartvaults_spend(self.uniffiClonePointer(), 
        FfiConverterTypeEventId_lower(policyId),
        FfiConverterString.lower(toAddress),
        FfiConverterTypeAmount.lower(amount),
        FfiConverterString.lower(description),
        FfiConverterUInt8.lower(targetBlocks),
        FfiConverterOptionSequenceTypeOutPoint.lower(utxos),
        FfiConverterOptionDictionaryStringSequenceUInt64.lower(policyPath),
        FfiConverterBool.lower(skipFrozenUtxos),$0
    )
}
        )
    }
    /**
     * Restart a previously stopped client
     */
    public func start()  {
        try! 
    rustCall() {
    
    uniffi_smartvaults_sdk_ffi_fn_method_smartvaults_start(self.uniffiClonePointer(), $0
    )
}
    }
    /**
     * Stop client
     *
     * Stop all threads and connections
     */
    public func stop() throws  {
        try 
    rustCallWithError(FfiConverterTypeSmartVaultsError.lift) {
    uniffi_smartvaults_sdk_ffi_fn_method_smartvaults_stop(self.uniffiClonePointer(), $0
    )
}
    }
    /**
     * Permanent delete the keychain
     */
    public func wipe(password: String) throws  {
        try 
    rustCallWithError(FfiConverterTypeSmartVaultsError.lift) {
    uniffi_smartvaults_sdk_ffi_fn_method_smartvaults_wipe(self.uniffiClonePointer(), 
        FfiConverterString.lower(password),$0
    )
}
    }

}

public struct FfiConverterTypeSmartVaults: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = SmartVaults

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> SmartVaults {
        return SmartVaults(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: SmartVaults) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SmartVaults {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: SmartVaults, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


public func FfiConverterTypeSmartVaults_lift(_ pointer: UnsafeMutableRawPointer) throws -> SmartVaults {
    return try FfiConverterTypeSmartVaults.lift(pointer)
}

public func FfiConverterTypeSmartVaults_lower(_ value: SmartVaults) -> UnsafeMutableRawPointer {
    return FfiConverterTypeSmartVaults.lower(value)
}




public protocol SmartVaultsLibraryProtocol : AnyObject {
    
    func gitHashVersion()  -> String
    
}
public class SmartVaultsLibrary:
    SmartVaultsLibraryProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_smartvaults_sdk_ffi_fn_clone_smartvaultslibrary(self.pointer, $0) }
    }
    public convenience init()  {
        self.init(unsafeFromRawPointer: try! rustCall() {
    uniffi_smartvaults_sdk_ffi_fn_constructor_smartvaultslibrary_new($0)
})
    }

    deinit {
        try! rustCall { uniffi_smartvaults_sdk_ffi_fn_free_smartvaultslibrary(pointer, $0) }
    }

    

    
    
    public func gitHashVersion()  -> String {
        return try!  FfiConverterString.lift(
            try! 
    rustCall() {
    
    uniffi_smartvaults_sdk_ffi_fn_method_smartvaultslibrary_git_hash_version(self.uniffiClonePointer(), $0
    )
}
        )
    }

}

public struct FfiConverterTypeSmartVaultsLibrary: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = SmartVaultsLibrary

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> SmartVaultsLibrary {
        return SmartVaultsLibrary(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: SmartVaultsLibrary) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SmartVaultsLibrary {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: SmartVaultsLibrary, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


public func FfiConverterTypeSmartVaultsLibrary_lift(_ pointer: UnsafeMutableRawPointer) throws -> SmartVaultsLibrary {
    return try FfiConverterTypeSmartVaultsLibrary.lift(pointer)
}

public func FfiConverterTypeSmartVaultsLibrary_lower(_ value: SmartVaultsLibrary) -> UnsafeMutableRawPointer {
    return FfiConverterTypeSmartVaultsLibrary.lower(value)
}




public protocol TransactionProtocol : AnyObject {
    
    func inputs()  -> [TxIn]
    
    func isExplicitlyRbf()  -> Bool
    
    func isLockTimeEnabled()  -> Bool
    
    func lockTime()  -> UInt32
    
    func outputs()  -> [TxOut]
    
    func size()  -> UInt64
    
    func txid()  -> String
    
    func version()  -> Int32
    
    func vsize()  -> UInt64
    
    func weight()  -> UInt64
    
}
public class Transaction:
    TransactionProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_smartvaults_sdk_ffi_fn_clone_transaction(self.pointer, $0) }
    }

    deinit {
        try! rustCall { uniffi_smartvaults_sdk_ffi_fn_free_transaction(pointer, $0) }
    }

    

    
    
    public func inputs()  -> [TxIn] {
        return try!  FfiConverterSequenceTypeTxIn.lift(
            try! 
    rustCall() {
    
    uniffi_smartvaults_sdk_ffi_fn_method_transaction_inputs(self.uniffiClonePointer(), $0
    )
}
        )
    }
    public func isExplicitlyRbf()  -> Bool {
        return try!  FfiConverterBool.lift(
            try! 
    rustCall() {
    
    uniffi_smartvaults_sdk_ffi_fn_method_transaction_is_explicitly_rbf(self.uniffiClonePointer(), $0
    )
}
        )
    }
    public func isLockTimeEnabled()  -> Bool {
        return try!  FfiConverterBool.lift(
            try! 
    rustCall() {
    
    uniffi_smartvaults_sdk_ffi_fn_method_transaction_is_lock_time_enabled(self.uniffiClonePointer(), $0
    )
}
        )
    }
    public func lockTime()  -> UInt32 {
        return try!  FfiConverterUInt32.lift(
            try! 
    rustCall() {
    
    uniffi_smartvaults_sdk_ffi_fn_method_transaction_lock_time(self.uniffiClonePointer(), $0
    )
}
        )
    }
    public func outputs()  -> [TxOut] {
        return try!  FfiConverterSequenceTypeTxOut.lift(
            try! 
    rustCall() {
    
    uniffi_smartvaults_sdk_ffi_fn_method_transaction_outputs(self.uniffiClonePointer(), $0
    )
}
        )
    }
    public func size()  -> UInt64 {
        return try!  FfiConverterUInt64.lift(
            try! 
    rustCall() {
    
    uniffi_smartvaults_sdk_ffi_fn_method_transaction_size(self.uniffiClonePointer(), $0
    )
}
        )
    }
    public func txid()  -> String {
        return try!  FfiConverterString.lift(
            try! 
    rustCall() {
    
    uniffi_smartvaults_sdk_ffi_fn_method_transaction_txid(self.uniffiClonePointer(), $0
    )
}
        )
    }
    public func version()  -> Int32 {
        return try!  FfiConverterInt32.lift(
            try! 
    rustCall() {
    
    uniffi_smartvaults_sdk_ffi_fn_method_transaction_version(self.uniffiClonePointer(), $0
    )
}
        )
    }
    public func vsize()  -> UInt64 {
        return try!  FfiConverterUInt64.lift(
            try! 
    rustCall() {
    
    uniffi_smartvaults_sdk_ffi_fn_method_transaction_vsize(self.uniffiClonePointer(), $0
    )
}
        )
    }
    public func weight()  -> UInt64 {
        return try!  FfiConverterUInt64.lift(
            try! 
    rustCall() {
    
    uniffi_smartvaults_sdk_ffi_fn_method_transaction_weight(self.uniffiClonePointer(), $0
    )
}
        )
    }

}

public struct FfiConverterTypeTransaction: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = Transaction

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Transaction {
        return Transaction(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: Transaction) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Transaction {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: Transaction, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


public func FfiConverterTypeTransaction_lift(_ pointer: UnsafeMutableRawPointer) throws -> Transaction {
    return try FfiConverterTypeTransaction.lift(pointer)
}

public func FfiConverterTypeTransaction_lower(_ value: Transaction) -> UnsafeMutableRawPointer {
    return FfiConverterTypeTransaction.lower(value)
}




public protocol TransactionDetailsProtocol : AnyObject {
    
    func confirmationTime()  -> BlockTime?
    
    func fee()  -> UInt64?
    
    func received()  -> UInt64
    
    func sent()  -> UInt64
    
    func total()  -> Int64
    
    func transaction()  -> Transaction
    
    func txid()  -> String
    
}
public class TransactionDetails:
    TransactionDetailsProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_smartvaults_sdk_ffi_fn_clone_transactiondetails(self.pointer, $0) }
    }

    deinit {
        try! rustCall { uniffi_smartvaults_sdk_ffi_fn_free_transactiondetails(pointer, $0) }
    }

    

    
    
    public func confirmationTime()  -> BlockTime? {
        return try!  FfiConverterOptionTypeBlockTime.lift(
            try! 
    rustCall() {
    
    uniffi_smartvaults_sdk_ffi_fn_method_transactiondetails_confirmation_time(self.uniffiClonePointer(), $0
    )
}
        )
    }
    public func fee()  -> UInt64? {
        return try!  FfiConverterOptionUInt64.lift(
            try! 
    rustCall() {
    
    uniffi_smartvaults_sdk_ffi_fn_method_transactiondetails_fee(self.uniffiClonePointer(), $0
    )
}
        )
    }
    public func received()  -> UInt64 {
        return try!  FfiConverterUInt64.lift(
            try! 
    rustCall() {
    
    uniffi_smartvaults_sdk_ffi_fn_method_transactiondetails_received(self.uniffiClonePointer(), $0
    )
}
        )
    }
    public func sent()  -> UInt64 {
        return try!  FfiConverterUInt64.lift(
            try! 
    rustCall() {
    
    uniffi_smartvaults_sdk_ffi_fn_method_transactiondetails_sent(self.uniffiClonePointer(), $0
    )
}
        )
    }
    public func total()  -> Int64 {
        return try!  FfiConverterInt64.lift(
            try! 
    rustCall() {
    
    uniffi_smartvaults_sdk_ffi_fn_method_transactiondetails_total(self.uniffiClonePointer(), $0
    )
}
        )
    }
    public func transaction()  -> Transaction {
        return try!  FfiConverterTypeTransaction.lift(
            try! 
    rustCall() {
    
    uniffi_smartvaults_sdk_ffi_fn_method_transactiondetails_transaction(self.uniffiClonePointer(), $0
    )
}
        )
    }
    public func txid()  -> String {
        return try!  FfiConverterString.lift(
            try! 
    rustCall() {
    
    uniffi_smartvaults_sdk_ffi_fn_method_transactiondetails_txid(self.uniffiClonePointer(), $0
    )
}
        )
    }

}

public struct FfiConverterTypeTransactionDetails: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = TransactionDetails

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> TransactionDetails {
        return TransactionDetails(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: TransactionDetails) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TransactionDetails {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: TransactionDetails, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


public func FfiConverterTypeTransactionDetails_lift(_ pointer: UnsafeMutableRawPointer) throws -> TransactionDetails {
    return try FfiConverterTypeTransactionDetails.lift(pointer)
}

public func FfiConverterTypeTransactionDetails_lower(_ value: TransactionDetails) -> UnsafeMutableRawPointer {
    return FfiConverterTypeTransactionDetails.lower(value)
}




public protocol TxInProtocol : AnyObject {
    
    func previousOutput()  -> OutPoint
    
}
public class TxIn:
    TxInProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_smartvaults_sdk_ffi_fn_clone_txin(self.pointer, $0) }
    }

    deinit {
        try! rustCall { uniffi_smartvaults_sdk_ffi_fn_free_txin(pointer, $0) }
    }

    

    
    
    public func previousOutput()  -> OutPoint {
        return try!  FfiConverterTypeOutPoint.lift(
            try! 
    rustCall() {
    
    uniffi_smartvaults_sdk_ffi_fn_method_txin_previous_output(self.uniffiClonePointer(), $0
    )
}
        )
    }

}

public struct FfiConverterTypeTxIn: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = TxIn

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> TxIn {
        return TxIn(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: TxIn) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TxIn {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: TxIn, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


public func FfiConverterTypeTxIn_lift(_ pointer: UnsafeMutableRawPointer) throws -> TxIn {
    return try FfiConverterTypeTxIn.lift(pointer)
}

public func FfiConverterTypeTxIn_lower(_ value: TxIn) -> UnsafeMutableRawPointer {
    return FfiConverterTypeTxIn.lower(value)
}




public protocol TxOutProtocol : AnyObject {
    
    func address(network: Network) throws  -> String
    
    func value()  -> UInt64
    
}
public class TxOut:
    TxOutProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_smartvaults_sdk_ffi_fn_clone_txout(self.pointer, $0) }
    }

    deinit {
        try! rustCall { uniffi_smartvaults_sdk_ffi_fn_free_txout(pointer, $0) }
    }

    

    
    
    public func address(network: Network) throws  -> String {
        return try  FfiConverterString.lift(
            try 
    rustCallWithError(FfiConverterTypeSmartVaultsError.lift) {
    uniffi_smartvaults_sdk_ffi_fn_method_txout_address(self.uniffiClonePointer(), 
        FfiConverterTypeNetwork.lower(network),$0
    )
}
        )
    }
    public func value()  -> UInt64 {
        return try!  FfiConverterUInt64.lift(
            try! 
    rustCall() {
    
    uniffi_smartvaults_sdk_ffi_fn_method_txout_value(self.uniffiClonePointer(), $0
    )
}
        )
    }

}

public struct FfiConverterTypeTxOut: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = TxOut

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> TxOut {
        return TxOut(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: TxOut) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TxOut {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: TxOut, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


public func FfiConverterTypeTxOut_lift(_ pointer: UnsafeMutableRawPointer) throws -> TxOut {
    return try FfiConverterTypeTxOut.lift(pointer)
}

public func FfiConverterTypeTxOut_lower(_ value: TxOut) -> UnsafeMutableRawPointer {
    return FfiConverterTypeTxOut.lower(value)
}




public protocol UtxoProtocol : AnyObject {
    
    func isSpent()  -> Bool
    
    func label()  -> String?
    
    func outpoint()  -> OutPoint
    
    func value()  -> UInt64
    
}
public class Utxo:
    UtxoProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_smartvaults_sdk_ffi_fn_clone_utxo(self.pointer, $0) }
    }

    deinit {
        try! rustCall { uniffi_smartvaults_sdk_ffi_fn_free_utxo(pointer, $0) }
    }

    

    
    
    public func isSpent()  -> Bool {
        return try!  FfiConverterBool.lift(
            try! 
    rustCall() {
    
    uniffi_smartvaults_sdk_ffi_fn_method_utxo_is_spent(self.uniffiClonePointer(), $0
    )
}
        )
    }
    public func label()  -> String? {
        return try!  FfiConverterOptionString.lift(
            try! 
    rustCall() {
    
    uniffi_smartvaults_sdk_ffi_fn_method_utxo_label(self.uniffiClonePointer(), $0
    )
}
        )
    }
    public func outpoint()  -> OutPoint {
        return try!  FfiConverterTypeOutPoint.lift(
            try! 
    rustCall() {
    
    uniffi_smartvaults_sdk_ffi_fn_method_utxo_outpoint(self.uniffiClonePointer(), $0
    )
}
        )
    }
    public func value()  -> UInt64 {
        return try!  FfiConverterUInt64.lift(
            try! 
    rustCall() {
    
    uniffi_smartvaults_sdk_ffi_fn_method_utxo_value(self.uniffiClonePointer(), $0
    )
}
        )
    }

}

public struct FfiConverterTypeUtxo: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = Utxo

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Utxo {
        return Utxo(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: Utxo) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Utxo {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: Utxo, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


public func FfiConverterTypeUtxo_lift(_ pointer: UnsafeMutableRawPointer) throws -> Utxo {
    return try FfiConverterTypeUtxo.lift(pointer)
}

public func FfiConverterTypeUtxo_lower(_ value: Utxo) -> UnsafeMutableRawPointer {
    return FfiConverterTypeUtxo.lower(value)
}


public struct KeyAgent {
    public var user: Profile
    public var signerOfferings: [SignerOffering]
    public var verified: Bool
    public var isContact: Bool

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        user: Profile, 
        signerOfferings: [SignerOffering], 
        verified: Bool, 
        isContact: Bool) {
        self.user = user
        self.signerOfferings = signerOfferings
        self.verified = verified
        self.isContact = isContact
    }
}



public struct FfiConverterTypeKeyAgent: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> KeyAgent {
        return
            try KeyAgent(
                user: FfiConverterTypeProfile.read(from: &buf), 
                signerOfferings: FfiConverterSequenceTypeSignerOffering.read(from: &buf), 
                verified: FfiConverterBool.read(from: &buf), 
                isContact: FfiConverterBool.read(from: &buf)
        )
    }

    public static func write(_ value: KeyAgent, into buf: inout [UInt8]) {
        FfiConverterTypeProfile.write(value.user, into: &buf)
        FfiConverterSequenceTypeSignerOffering.write(value.signerOfferings, into: &buf)
        FfiConverterBool.write(value.verified, into: &buf)
        FfiConverterBool.write(value.isContact, into: &buf)
    }
}


public func FfiConverterTypeKeyAgent_lift(_ buf: RustBuffer) throws -> KeyAgent {
    return try FfiConverterTypeKeyAgent.lift(buf)
}

public func FfiConverterTypeKeyAgent_lower(_ value: KeyAgent) -> RustBuffer {
    return FfiConverterTypeKeyAgent.lower(value)
}


public struct NostrConnectSession {
    public var uri: NostrConnectUri
    public var timestamp: UInt64

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        uri: NostrConnectUri, 
        timestamp: UInt64) {
        self.uri = uri
        self.timestamp = timestamp
    }
}



public struct FfiConverterTypeNostrConnectSession: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NostrConnectSession {
        return
            try NostrConnectSession(
                uri: FfiConverterTypeNostrConnectURI.read(from: &buf), 
                timestamp: FfiConverterUInt64.read(from: &buf)
        )
    }

    public static func write(_ value: NostrConnectSession, into buf: inout [UInt8]) {
        FfiConverterTypeNostrConnectURI.write(value.uri, into: &buf)
        FfiConverterUInt64.write(value.timestamp, into: &buf)
    }
}


public func FfiConverterTypeNostrConnectSession_lift(_ buf: RustBuffer) throws -> NostrConnectSession {
    return try FfiConverterTypeNostrConnectSession.lift(buf)
}

public func FfiConverterTypeNostrConnectSession_lower(_ value: NostrConnectSession) -> RustBuffer {
    return FfiConverterTypeNostrConnectSession.lower(value)
}


public struct Period {
    public var from: Timestamp
    public var to: Timestamp

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        from: Timestamp, 
        to: Timestamp) {
        self.from = from
        self.to = to
    }
}



public struct FfiConverterTypePeriod: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Period {
        return
            try Period(
                from: FfiConverterTypeTimestamp.read(from: &buf), 
                to: FfiConverterTypeTimestamp.read(from: &buf)
        )
    }

    public static func write(_ value: Period, into buf: inout [UInt8]) {
        FfiConverterTypeTimestamp.write(value.from, into: &buf)
        FfiConverterTypeTimestamp.write(value.to, into: &buf)
    }
}


public func FfiConverterTypePeriod_lift(_ buf: RustBuffer) throws -> Period {
    return try FfiConverterTypePeriod.lift(buf)
}

public func FfiConverterTypePeriod_lower(_ value: Period) -> RustBuffer {
    return FfiConverterTypePeriod.lower(value)
}


public struct PolicyPathSigner {
    public var signer: Signer
    public var policyPath: PolicyPathSelector?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        signer: Signer, 
        policyPath: PolicyPathSelector?) {
        self.signer = signer
        self.policyPath = policyPath
    }
}



public struct FfiConverterTypePolicyPathSigner: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PolicyPathSigner {
        return
            try PolicyPathSigner(
                signer: FfiConverterTypeSigner.read(from: &buf), 
                policyPath: FfiConverterOptionTypePolicyPathSelector.read(from: &buf)
        )
    }

    public static func write(_ value: PolicyPathSigner, into buf: inout [UInt8]) {
        FfiConverterTypeSigner.write(value.signer, into: &buf)
        FfiConverterOptionTypePolicyPathSelector.write(value.policyPath, into: &buf)
    }
}


public func FfiConverterTypePolicyPathSigner_lift(_ buf: RustBuffer) throws -> PolicyPathSigner {
    return try FfiConverterTypePolicyPathSigner.lift(buf)
}

public func FfiConverterTypePolicyPathSigner_lower(_ value: PolicyPathSigner) -> RustBuffer {
    return FfiConverterTypePolicyPathSigner.lower(value)
}


public struct SignerOffering {
    public var temperature: Temperature
    public var responseTime: UInt16
    public var deviceType: DeviceType
    public var costPerSignature: Price?
    public var yearlyCostBasisPoints: UInt64?
    public var yearlyCost: Price?
    public var network: Network

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        temperature: Temperature, 
        responseTime: UInt16, 
        deviceType: DeviceType, 
        costPerSignature: Price?, 
        yearlyCostBasisPoints: UInt64?, 
        yearlyCost: Price?, 
        network: Network) {
        self.temperature = temperature
        self.responseTime = responseTime
        self.deviceType = deviceType
        self.costPerSignature = costPerSignature
        self.yearlyCostBasisPoints = yearlyCostBasisPoints
        self.yearlyCost = yearlyCost
        self.network = network
    }
}



public struct FfiConverterTypeSignerOffering: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SignerOffering {
        return
            try SignerOffering(
                temperature: FfiConverterTypeTemperature.read(from: &buf), 
                responseTime: FfiConverterUInt16.read(from: &buf), 
                deviceType: FfiConverterTypeDeviceType.read(from: &buf), 
                costPerSignature: FfiConverterOptionTypePrice.read(from: &buf), 
                yearlyCostBasisPoints: FfiConverterOptionUInt64.read(from: &buf), 
                yearlyCost: FfiConverterOptionTypePrice.read(from: &buf), 
                network: FfiConverterTypeNetwork.read(from: &buf)
        )
    }

    public static func write(_ value: SignerOffering, into buf: inout [UInt8]) {
        FfiConverterTypeTemperature.write(value.temperature, into: &buf)
        FfiConverterUInt16.write(value.responseTime, into: &buf)
        FfiConverterTypeDeviceType.write(value.deviceType, into: &buf)
        FfiConverterOptionTypePrice.write(value.costPerSignature, into: &buf)
        FfiConverterOptionUInt64.write(value.yearlyCostBasisPoints, into: &buf)
        FfiConverterOptionTypePrice.write(value.yearlyCost, into: &buf)
        FfiConverterTypeNetwork.write(value.network, into: &buf)
    }
}


public func FfiConverterTypeSignerOffering_lift(_ buf: RustBuffer) throws -> SignerOffering {
    return try FfiConverterTypeSignerOffering.lift(buf)
}

public func FfiConverterTypeSignerOffering_lower(_ value: SignerOffering) -> RustBuffer {
    return FfiConverterTypeSignerOffering.lower(value)
}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum AddressIndex {
    
    case new
    case lastUnused
    case peek(
        index: UInt32
    )
}

public struct FfiConverterTypeAddressIndex: FfiConverterRustBuffer {
    typealias SwiftType = AddressIndex

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AddressIndex {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .new
        
        case 2: return .lastUnused
        
        case 3: return .peek(
            index: try FfiConverterUInt32.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: AddressIndex, into buf: inout [UInt8]) {
        switch value {
        
        
        case .new:
            writeInt(&buf, Int32(1))
        
        
        case .lastUnused:
            writeInt(&buf, Int32(2))
        
        
        case let .peek(index):
            writeInt(&buf, Int32(3))
            FfiConverterUInt32.write(index, into: &buf)
            
        }
    }
}


public func FfiConverterTypeAddressIndex_lift(_ buf: RustBuffer) throws -> AddressIndex {
    return try FfiConverterTypeAddressIndex.lift(buf)
}

public func FfiConverterTypeAddressIndex_lower(_ value: AddressIndex) -> RustBuffer {
    return FfiConverterTypeAddressIndex.lower(value)
}


extension AddressIndex: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum ApprovedProposal {
    
    case spending(
        psbt: String
    )
    case keyAgentPayment(
        psbt: String
    )
    case proofOfReserve(
        psbt: String
    )
}

public struct FfiConverterTypeApprovedProposal: FfiConverterRustBuffer {
    typealias SwiftType = ApprovedProposal

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ApprovedProposal {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .spending(
            psbt: try FfiConverterString.read(from: &buf)
        )
        
        case 2: return .keyAgentPayment(
            psbt: try FfiConverterString.read(from: &buf)
        )
        
        case 3: return .proofOfReserve(
            psbt: try FfiConverterString.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ApprovedProposal, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .spending(psbt):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(psbt, into: &buf)
            
        
        case let .keyAgentPayment(psbt):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(psbt, into: &buf)
            
        
        case let .proofOfReserve(psbt):
            writeInt(&buf, Int32(3))
            FfiConverterString.write(psbt, into: &buf)
            
        }
    }
}


public func FfiConverterTypeApprovedProposal_lift(_ buf: RustBuffer) throws -> ApprovedProposal {
    return try FfiConverterTypeApprovedProposal.lift(buf)
}

public func FfiConverterTypeApprovedProposal_lower(_ value: ApprovedProposal) -> RustBuffer {
    return FfiConverterTypeApprovedProposal.lower(value)
}


extension ApprovedProposal: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum CompletedProposal {
    
    case spending(
        txid: String, 
        description: String
    )
    case keyAgentPayment(
        txid: String, 
        signerDescriptor: String, 
        description: String, 
        period: Period
    )
    case proofOfReserve(
        descriptor: String, 
        message: String, 
        psbt: String
    )
}

public struct FfiConverterTypeCompletedProposal: FfiConverterRustBuffer {
    typealias SwiftType = CompletedProposal

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> CompletedProposal {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .spending(
            txid: try FfiConverterString.read(from: &buf), 
            description: try FfiConverterString.read(from: &buf)
        )
        
        case 2: return .keyAgentPayment(
            txid: try FfiConverterString.read(from: &buf), 
            signerDescriptor: try FfiConverterString.read(from: &buf), 
            description: try FfiConverterString.read(from: &buf), 
            period: try FfiConverterTypePeriod.read(from: &buf)
        )
        
        case 3: return .proofOfReserve(
            descriptor: try FfiConverterString.read(from: &buf), 
            message: try FfiConverterString.read(from: &buf), 
            psbt: try FfiConverterString.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: CompletedProposal, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .spending(txid,description):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(txid, into: &buf)
            FfiConverterString.write(description, into: &buf)
            
        
        case let .keyAgentPayment(txid,signerDescriptor,description,period):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(txid, into: &buf)
            FfiConverterString.write(signerDescriptor, into: &buf)
            FfiConverterString.write(description, into: &buf)
            FfiConverterTypePeriod.write(period, into: &buf)
            
        
        case let .proofOfReserve(descriptor,message,psbt):
            writeInt(&buf, Int32(3))
            FfiConverterString.write(descriptor, into: &buf)
            FfiConverterString.write(message, into: &buf)
            FfiConverterString.write(psbt, into: &buf)
            
        }
    }
}


public func FfiConverterTypeCompletedProposal_lift(_ buf: RustBuffer) throws -> CompletedProposal {
    return try FfiConverterTypeCompletedProposal.lift(buf)
}

public func FfiConverterTypeCompletedProposal_lower(_ value: CompletedProposal) -> RustBuffer {
    return FfiConverterTypeCompletedProposal.lower(value)
}




// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum DeviceType {
    
    case coldcard
    case bitBox02
    case ledger
    case mobile
    case desktop
    case cloudBased
    case undisclosed
    case unknown
}

public struct FfiConverterTypeDeviceType: FfiConverterRustBuffer {
    typealias SwiftType = DeviceType

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DeviceType {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .coldcard
        
        case 2: return .bitBox02
        
        case 3: return .ledger
        
        case 4: return .mobile
        
        case 5: return .desktop
        
        case 6: return .cloudBased
        
        case 7: return .undisclosed
        
        case 8: return .unknown
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: DeviceType, into buf: inout [UInt8]) {
        switch value {
        
        
        case .coldcard:
            writeInt(&buf, Int32(1))
        
        
        case .bitBox02:
            writeInt(&buf, Int32(2))
        
        
        case .ledger:
            writeInt(&buf, Int32(3))
        
        
        case .mobile:
            writeInt(&buf, Int32(4))
        
        
        case .desktop:
            writeInt(&buf, Int32(5))
        
        
        case .cloudBased:
            writeInt(&buf, Int32(6))
        
        
        case .undisclosed:
            writeInt(&buf, Int32(7))
        
        
        case .unknown:
            writeInt(&buf, Int32(8))
        
        }
    }
}


public func FfiConverterTypeDeviceType_lift(_ buf: RustBuffer) throws -> DeviceType {
    return try FfiConverterTypeDeviceType.lift(buf)
}

public func FfiConverterTypeDeviceType_lower(_ value: DeviceType) -> RustBuffer {
    return FfiConverterTypeDeviceType.lower(value)
}


extension DeviceType: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum EventHandled {
    
    case sharedKey(
        eventId: EventId
    )
    case policy(
        policyId: EventId
    )
    case proposal(
        proposalId: EventId
    )
    case approval(
        proposalId: EventId
    )
    case completedProposal(
        completedProposalId: EventId
    )
    case signer(
        signerId: EventId
    )
    case mySharedSigner(
        mySharedSignerId: EventId
    )
    case sharedSigner(
        sharedSignerId: EventId
    )
    case contacts
    case metadata(
        publicKey: PublicKey
    )
    case nostrConnectRequest(
        requestId: EventId
    )
    case label
    case eventDeletion
    case relayList
    case keyAgentSignerOffering
    case verifiedKeyAgents
}

public struct FfiConverterTypeEventHandled: FfiConverterRustBuffer {
    typealias SwiftType = EventHandled

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> EventHandled {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .sharedKey(
            eventId: try FfiConverterTypeEventId.read(from: &buf)
        )
        
        case 2: return .policy(
            policyId: try FfiConverterTypeEventId.read(from: &buf)
        )
        
        case 3: return .proposal(
            proposalId: try FfiConverterTypeEventId.read(from: &buf)
        )
        
        case 4: return .approval(
            proposalId: try FfiConverterTypeEventId.read(from: &buf)
        )
        
        case 5: return .completedProposal(
            completedProposalId: try FfiConverterTypeEventId.read(from: &buf)
        )
        
        case 6: return .signer(
            signerId: try FfiConverterTypeEventId.read(from: &buf)
        )
        
        case 7: return .mySharedSigner(
            mySharedSignerId: try FfiConverterTypeEventId.read(from: &buf)
        )
        
        case 8: return .sharedSigner(
            sharedSignerId: try FfiConverterTypeEventId.read(from: &buf)
        )
        
        case 9: return .contacts
        
        case 10: return .metadata(
            publicKey: try FfiConverterTypePublicKey.read(from: &buf)
        )
        
        case 11: return .nostrConnectRequest(
            requestId: try FfiConverterTypeEventId.read(from: &buf)
        )
        
        case 12: return .label
        
        case 13: return .eventDeletion
        
        case 14: return .relayList
        
        case 15: return .keyAgentSignerOffering
        
        case 16: return .verifiedKeyAgents
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: EventHandled, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .sharedKey(eventId):
            writeInt(&buf, Int32(1))
            FfiConverterTypeEventId.write(eventId, into: &buf)
            
        
        case let .policy(policyId):
            writeInt(&buf, Int32(2))
            FfiConverterTypeEventId.write(policyId, into: &buf)
            
        
        case let .proposal(proposalId):
            writeInt(&buf, Int32(3))
            FfiConverterTypeEventId.write(proposalId, into: &buf)
            
        
        case let .approval(proposalId):
            writeInt(&buf, Int32(4))
            FfiConverterTypeEventId.write(proposalId, into: &buf)
            
        
        case let .completedProposal(completedProposalId):
            writeInt(&buf, Int32(5))
            FfiConverterTypeEventId.write(completedProposalId, into: &buf)
            
        
        case let .signer(signerId):
            writeInt(&buf, Int32(6))
            FfiConverterTypeEventId.write(signerId, into: &buf)
            
        
        case let .mySharedSigner(mySharedSignerId):
            writeInt(&buf, Int32(7))
            FfiConverterTypeEventId.write(mySharedSignerId, into: &buf)
            
        
        case let .sharedSigner(sharedSignerId):
            writeInt(&buf, Int32(8))
            FfiConverterTypeEventId.write(sharedSignerId, into: &buf)
            
        
        case .contacts:
            writeInt(&buf, Int32(9))
        
        
        case let .metadata(publicKey):
            writeInt(&buf, Int32(10))
            FfiConverterTypePublicKey.write(publicKey, into: &buf)
            
        
        case let .nostrConnectRequest(requestId):
            writeInt(&buf, Int32(11))
            FfiConverterTypeEventId.write(requestId, into: &buf)
            
        
        case .label:
            writeInt(&buf, Int32(12))
        
        
        case .eventDeletion:
            writeInt(&buf, Int32(13))
        
        
        case .relayList:
            writeInt(&buf, Int32(14))
        
        
        case .keyAgentSignerOffering:
            writeInt(&buf, Int32(15))
        
        
        case .verifiedKeyAgents:
            writeInt(&buf, Int32(16))
        
        }
    }
}


public func FfiConverterTypeEventHandled_lift(_ buf: RustBuffer) throws -> EventHandled {
    return try FfiConverterTypeEventHandled.lift(buf)
}

public func FfiConverterTypeEventHandled_lower(_ value: EventHandled) -> RustBuffer {
    return FfiConverterTypeEventHandled.lower(value)
}




// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum Message {
    
    case eventHandled(
        event: EventHandled
    )
    case walletSyncCompleted(
        policyId: EventId
    )
    case blockHeightUpdated
}

public struct FfiConverterTypeMessage: FfiConverterRustBuffer {
    typealias SwiftType = Message

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Message {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .eventHandled(
            event: try FfiConverterTypeEventHandled.read(from: &buf)
        )
        
        case 2: return .walletSyncCompleted(
            policyId: try FfiConverterTypeEventId.read(from: &buf)
        )
        
        case 3: return .blockHeightUpdated
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: Message, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .eventHandled(event):
            writeInt(&buf, Int32(1))
            FfiConverterTypeEventHandled.write(event, into: &buf)
            
        
        case let .walletSyncCompleted(policyId):
            writeInt(&buf, Int32(2))
            FfiConverterTypeEventId.write(policyId, into: &buf)
            
        
        case .blockHeightUpdated:
            writeInt(&buf, Int32(3))
        
        }
    }
}


public func FfiConverterTypeMessage_lift(_ buf: RustBuffer) throws -> Message {
    return try FfiConverterTypeMessage.lift(buf)
}

public func FfiConverterTypeMessage_lower(_ value: Message) -> RustBuffer {
    return FfiConverterTypeMessage.lower(value)
}




// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum Network {
    
    case bitcoin
    case testnet
    case signet
    case regtest
}

public struct FfiConverterTypeNetwork: FfiConverterRustBuffer {
    typealias SwiftType = Network

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Network {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .bitcoin
        
        case 2: return .testnet
        
        case 3: return .signet
        
        case 4: return .regtest
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: Network, into buf: inout [UInt8]) {
        switch value {
        
        
        case .bitcoin:
            writeInt(&buf, Int32(1))
        
        
        case .testnet:
            writeInt(&buf, Int32(2))
        
        
        case .signet:
            writeInt(&buf, Int32(3))
        
        
        case .regtest:
            writeInt(&buf, Int32(4))
        
        }
    }
}


public func FfiConverterTypeNetwork_lift(_ buf: RustBuffer) throws -> Network {
    return try FfiConverterTypeNetwork.lift(buf)
}

public func FfiConverterTypeNetwork_lower(_ value: Network) -> RustBuffer {
    return FfiConverterTypeNetwork.lower(value)
}


extension Network: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum PolicyPath {
    
    case single(
        pp: PolicyPathSelector
    )
    case multiple(
        list: [PolicyPathSigner]
    )
    case none
}

public struct FfiConverterTypePolicyPath: FfiConverterRustBuffer {
    typealias SwiftType = PolicyPath

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PolicyPath {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .single(
            pp: try FfiConverterTypePolicyPathSelector.read(from: &buf)
        )
        
        case 2: return .multiple(
            list: try FfiConverterSequenceTypePolicyPathSigner.read(from: &buf)
        )
        
        case 3: return .none
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: PolicyPath, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .single(pp):
            writeInt(&buf, Int32(1))
            FfiConverterTypePolicyPathSelector.write(pp, into: &buf)
            
        
        case let .multiple(list):
            writeInt(&buf, Int32(2))
            FfiConverterSequenceTypePolicyPathSigner.write(list, into: &buf)
            
        
        case .none:
            writeInt(&buf, Int32(3))
        
        }
    }
}


public func FfiConverterTypePolicyPath_lift(_ buf: RustBuffer) throws -> PolicyPath {
    return try FfiConverterTypePolicyPath.lift(buf)
}

public func FfiConverterTypePolicyPath_lower(_ value: PolicyPath) -> RustBuffer {
    return FfiConverterTypePolicyPath.lower(value)
}




// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum PolicyPathSelector {
    
    case complete(
        path: [String: [UInt64]]
    )
    case partial(
        selectedPath: [String: [UInt64]], 
        missingToSelect: [String: [String]]
    )
}

public struct FfiConverterTypePolicyPathSelector: FfiConverterRustBuffer {
    typealias SwiftType = PolicyPathSelector

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PolicyPathSelector {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .complete(
            path: try FfiConverterDictionaryStringSequenceUInt64.read(from: &buf)
        )
        
        case 2: return .partial(
            selectedPath: try FfiConverterDictionaryStringSequenceUInt64.read(from: &buf), 
            missingToSelect: try FfiConverterDictionaryStringSequenceString.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: PolicyPathSelector, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .complete(path):
            writeInt(&buf, Int32(1))
            FfiConverterDictionaryStringSequenceUInt64.write(path, into: &buf)
            
        
        case let .partial(selectedPath,missingToSelect):
            writeInt(&buf, Int32(2))
            FfiConverterDictionaryStringSequenceUInt64.write(selectedPath, into: &buf)
            FfiConverterDictionaryStringSequenceString.write(missingToSelect, into: &buf)
            
        }
    }
}


public func FfiConverterTypePolicyPathSelector_lift(_ buf: RustBuffer) throws -> PolicyPathSelector {
    return try FfiConverterTypePolicyPathSelector.lift(buf)
}

public func FfiConverterTypePolicyPathSelector_lower(_ value: PolicyPathSelector) -> RustBuffer {
    return FfiConverterTypePolicyPathSelector.lower(value)
}


extension PolicyPathSelector: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum PolicyTemplateType {
    
    case multisig
    /**
     * Social Recovery / Inheritance
     */
    case recovery
    case hold
    case decaying
}

public struct FfiConverterTypePolicyTemplateType: FfiConverterRustBuffer {
    typealias SwiftType = PolicyTemplateType

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PolicyTemplateType {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .multisig
        
        case 2: return .recovery
        
        case 3: return .hold
        
        case 4: return .decaying
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: PolicyTemplateType, into buf: inout [UInt8]) {
        switch value {
        
        
        case .multisig:
            writeInt(&buf, Int32(1))
        
        
        case .recovery:
            writeInt(&buf, Int32(2))
        
        
        case .hold:
            writeInt(&buf, Int32(3))
        
        
        case .decaying:
            writeInt(&buf, Int32(4))
        
        }
    }
}


public func FfiConverterTypePolicyTemplateType_lift(_ buf: RustBuffer) throws -> PolicyTemplateType {
    return try FfiConverterTypePolicyTemplateType.lift(buf)
}

public func FfiConverterTypePolicyTemplateType_lower(_ value: PolicyTemplateType) -> RustBuffer {
    return FfiConverterTypePolicyTemplateType.lower(value)
}


extension PolicyTemplateType: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum Proposal {
    
    case spending(
        descriptor: String, 
        toAddress: String, 
        amount: UInt64, 
        description: String, 
        psbt: String
    )
    case keyAgentPayment(
        descriptor: String, 
        signerDescriptor: String, 
        amount: UInt64, 
        description: String, 
        period: Period, 
        psbt: String
    )
    case proofOfReserve(
        descriptor: String, 
        message: String, 
        psbt: String
    )
}

public struct FfiConverterTypeProposal: FfiConverterRustBuffer {
    typealias SwiftType = Proposal

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Proposal {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .spending(
            descriptor: try FfiConverterString.read(from: &buf), 
            toAddress: try FfiConverterString.read(from: &buf), 
            amount: try FfiConverterUInt64.read(from: &buf), 
            description: try FfiConverterString.read(from: &buf), 
            psbt: try FfiConverterString.read(from: &buf)
        )
        
        case 2: return .keyAgentPayment(
            descriptor: try FfiConverterString.read(from: &buf), 
            signerDescriptor: try FfiConverterString.read(from: &buf), 
            amount: try FfiConverterUInt64.read(from: &buf), 
            description: try FfiConverterString.read(from: &buf), 
            period: try FfiConverterTypePeriod.read(from: &buf), 
            psbt: try FfiConverterString.read(from: &buf)
        )
        
        case 3: return .proofOfReserve(
            descriptor: try FfiConverterString.read(from: &buf), 
            message: try FfiConverterString.read(from: &buf), 
            psbt: try FfiConverterString.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: Proposal, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .spending(descriptor,toAddress,amount,description,psbt):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(descriptor, into: &buf)
            FfiConverterString.write(toAddress, into: &buf)
            FfiConverterUInt64.write(amount, into: &buf)
            FfiConverterString.write(description, into: &buf)
            FfiConverterString.write(psbt, into: &buf)
            
        
        case let .keyAgentPayment(descriptor,signerDescriptor,amount,description,period,psbt):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(descriptor, into: &buf)
            FfiConverterString.write(signerDescriptor, into: &buf)
            FfiConverterUInt64.write(amount, into: &buf)
            FfiConverterString.write(description, into: &buf)
            FfiConverterTypePeriod.write(period, into: &buf)
            FfiConverterString.write(psbt, into: &buf)
            
        
        case let .proofOfReserve(descriptor,message,psbt):
            writeInt(&buf, Int32(3))
            FfiConverterString.write(descriptor, into: &buf)
            FfiConverterString.write(message, into: &buf)
            FfiConverterString.write(psbt, into: &buf)
            
        }
    }
}


public func FfiConverterTypeProposal_lift(_ buf: RustBuffer) throws -> Proposal {
    return try FfiConverterTypeProposal.lift(buf)
}

public func FfiConverterTypeProposal_lower(_ value: Proposal) -> RustBuffer {
    return FfiConverterTypeProposal.lower(value)
}




// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum SignerType {
    
    case seed
    case hardware
    case airGap
}

public struct FfiConverterTypeSignerType: FfiConverterRustBuffer {
    typealias SwiftType = SignerType

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SignerType {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .seed
        
        case 2: return .hardware
        
        case 3: return .airGap
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: SignerType, into buf: inout [UInt8]) {
        switch value {
        
        
        case .seed:
            writeInt(&buf, Int32(1))
        
        
        case .hardware:
            writeInt(&buf, Int32(2))
        
        
        case .airGap:
            writeInt(&buf, Int32(3))
        
        }
    }
}


public func FfiConverterTypeSignerType_lift(_ buf: RustBuffer) throws -> SignerType {
    return try FfiConverterTypeSignerType.lift(buf)
}

public func FfiConverterTypeSignerType_lower(_ value: SignerType) -> RustBuffer {
    return FfiConverterTypeSignerType.lower(value)
}


extension SignerType: Equatable, Hashable {}




public enum SmartVaultsError {

    
    
    case Generic(
        err: String
    )

    fileprivate static func uniffiErrorHandler(_ error: RustBuffer) throws -> Error {
        return try FfiConverterTypeSmartVaultsError.lift(error)
    }
}


public struct FfiConverterTypeSmartVaultsError: FfiConverterRustBuffer {
    typealias SwiftType = SmartVaultsError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SmartVaultsError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .Generic(
            err: try FfiConverterString.read(from: &buf)
            )

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: SmartVaultsError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case let .Generic(err):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(err, into: &buf)
            
        }
    }
}


extension SmartVaultsError: Equatable, Hashable {}

extension SmartVaultsError: Error { }

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum Temperature {
    
    case warm
    case cold
    case airGapped
    case unknown
}

public struct FfiConverterTypeTemperature: FfiConverterRustBuffer {
    typealias SwiftType = Temperature

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Temperature {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .warm
        
        case 2: return .cold
        
        case 3: return .airGapped
        
        case 4: return .unknown
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: Temperature, into buf: inout [UInt8]) {
        switch value {
        
        
        case .warm:
            writeInt(&buf, Int32(1))
        
        
        case .cold:
            writeInt(&buf, Int32(2))
        
        
        case .airGapped:
            writeInt(&buf, Int32(3))
        
        
        case .unknown:
            writeInt(&buf, Int32(4))
        
        }
    }
}


public func FfiConverterTypeTemperature_lift(_ buf: RustBuffer) throws -> Temperature {
    return try FfiConverterTypeTemperature.lift(buf)
}

public func FfiConverterTypeTemperature_lower(_ value: Temperature) -> RustBuffer {
    return FfiConverterTypeTemperature.lower(value)
}


extension Temperature: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum WordCount {
    
    case w12
    case w18
    case w24
}

public struct FfiConverterTypeWordCount: FfiConverterRustBuffer {
    typealias SwiftType = WordCount

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> WordCount {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .w12
        
        case 2: return .w18
        
        case 3: return .w24
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: WordCount, into buf: inout [UInt8]) {
        switch value {
        
        
        case .w12:
            writeInt(&buf, Int32(1))
        
        
        case .w18:
            writeInt(&buf, Int32(2))
        
        
        case .w24:
            writeInt(&buf, Int32(3))
        
        }
    }
}


public func FfiConverterTypeWordCount_lift(_ buf: RustBuffer) throws -> WordCount {
    return try FfiConverterTypeWordCount.lift(buf)
}

public func FfiConverterTypeWordCount_lower(_ value: WordCount) -> RustBuffer {
    return FfiConverterTypeWordCount.lower(value)
}


extension WordCount: Equatable, Hashable {}






public protocol SyncHandler : AnyObject {
    
    func handle(msg: Message) 
    
}
fileprivate extension NSLock {
    func withLock<T>(f: () throws -> T) rethrows -> T {
        self.lock()
        defer { self.unlock() }
        return try f()
    }
}

fileprivate typealias UniFFICallbackHandle = UInt64
fileprivate class UniFFICallbackHandleMap<T> {
    private var leftMap: [UniFFICallbackHandle: T] = [:]
    private var counter: [UniFFICallbackHandle: UInt64] = [:]
    private var rightMap: [ObjectIdentifier: UniFFICallbackHandle] = [:]

    private let lock = NSLock()
    private var currentHandle: UniFFICallbackHandle = 1
    private let stride: UniFFICallbackHandle = 1

    func insert(obj: T) -> UniFFICallbackHandle {
        lock.withLock {
            let id = ObjectIdentifier(obj as AnyObject)
            let handle = rightMap[id] ?? {
                currentHandle += stride
                let handle = currentHandle
                leftMap[handle] = obj
                rightMap[id] = handle
                return handle
            }()
            counter[handle] = (counter[handle] ?? 0) + 1
            return handle
        }
    }

    func get(handle: UniFFICallbackHandle) -> T? {
        lock.withLock {
            leftMap[handle]
        }
    }

    func delete(handle: UniFFICallbackHandle) {
        remove(handle: handle)
    }

    @discardableResult
    func remove(handle: UniFFICallbackHandle) -> T? {
        lock.withLock {
            defer { counter[handle] = (counter[handle] ?? 1) - 1 }
            guard counter[handle] == 1 else { return leftMap[handle] }
            let obj = leftMap.removeValue(forKey: handle)
            if let obj = obj {
                rightMap.removeValue(forKey: ObjectIdentifier(obj as AnyObject))
            }
            return obj
        }
    }
}

// Magic number for the Rust proxy to call using the same mechanism as every other method,
// to free the callback once it's dropped by Rust.
private let IDX_CALLBACK_FREE: Int32 = 0
// Callback return codes
private let UNIFFI_CALLBACK_SUCCESS: Int32 = 0
private let UNIFFI_CALLBACK_ERROR: Int32 = 1
private let UNIFFI_CALLBACK_UNEXPECTED_ERROR: Int32 = 2

// Declaration and FfiConverters for SyncHandler Callback Interface

fileprivate let uniffiCallbackHandlerSyncHandler : ForeignCallback =
    { (handle: UniFFICallbackHandle, method: Int32, argsData: UnsafePointer<UInt8>, argsLen: Int32, out_buf: UnsafeMutablePointer<RustBuffer>) -> Int32 in
    

    func invokeHandle(_ swiftCallbackInterface: SyncHandler, _ argsData: UnsafePointer<UInt8>, _ argsLen: Int32, _ out_buf: UnsafeMutablePointer<RustBuffer>) throws -> Int32 {
        var reader = createReader(data: Data(bytes: argsData, count: Int(argsLen)))
        func makeCall() throws -> Int32 {
            swiftCallbackInterface.handle(
                    msg:  try FfiConverterTypeMessage.read(from: &reader)
                    )
            return UNIFFI_CALLBACK_SUCCESS
        }
        return try makeCall()
    }


    switch method {
        case IDX_CALLBACK_FREE:
            FfiConverterCallbackInterfaceSyncHandler.handleMap.remove(handle: handle)
            // Sucessful return
            // See docs of ForeignCallback in `uniffi_core/src/ffi/foreigncallbacks.rs`
            return UNIFFI_CALLBACK_SUCCESS
        case 1:
            guard let cb = FfiConverterCallbackInterfaceSyncHandler.handleMap.get(handle: handle) else {
                out_buf.pointee = FfiConverterString.lower("No callback in handlemap; this is a Uniffi bug")
                return UNIFFI_CALLBACK_UNEXPECTED_ERROR
            }
            do {
                return try invokeHandle(cb, argsData, argsLen, out_buf)
            } catch let error {
                out_buf.pointee = FfiConverterString.lower(String(describing: error))
                return UNIFFI_CALLBACK_UNEXPECTED_ERROR
            }
        
        // This should never happen, because an out of bounds method index won't
        // ever be used. Once we can catch errors, we should return an InternalError.
        // https://github.com/mozilla/uniffi-rs/issues/351
        default:
            // An unexpected error happened.
            // See docs of ForeignCallback in `uniffi_core/src/ffi/foreigncallbacks.rs`
            return UNIFFI_CALLBACK_UNEXPECTED_ERROR
    }
}

private func uniffiCallbackInitSyncHandler() {
    uniffi_smartvaults_sdk_ffi_fn_init_callback_synchandler(uniffiCallbackHandlerSyncHandler)
}

// FfiConverter protocol for callback interfaces
fileprivate struct FfiConverterCallbackInterfaceSyncHandler {
    fileprivate static var handleMap = UniFFICallbackHandleMap<SyncHandler>()
}

extension FfiConverterCallbackInterfaceSyncHandler : FfiConverter {
    typealias SwiftType = SyncHandler
    // We can use Handle as the FfiType because it's a typealias to UInt64
    typealias FfiType = UniFFICallbackHandle

    public static func lift(_ handle: UniFFICallbackHandle) throws -> SwiftType {
        guard let callback = handleMap.get(handle: handle) else {
            throw UniffiInternalError.unexpectedStaleHandle
        }
        return callback
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        let handle: UniFFICallbackHandle = try readInt(&buf)
        return try lift(handle)
    }

    public static func lower(_ v: SwiftType) -> UniFFICallbackHandle {
        return handleMap.insert(obj: v)
    }

    public static func write(_ v: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(v))
    }
}

fileprivate struct FfiConverterOptionUInt64: FfiConverterRustBuffer {
    typealias SwiftType = UInt64?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterUInt64.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterUInt64.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionString: FfiConverterRustBuffer {
    typealias SwiftType = String?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterString.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterString.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeBalance: FfiConverterRustBuffer {
    typealias SwiftType = Balance?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeBalance.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeBalance.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeBlockTime: FfiConverterRustBuffer {
    typealias SwiftType = BlockTime?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeBlockTime.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeBlockTime.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypePrice: FfiConverterRustBuffer {
    typealias SwiftType = Price?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypePrice.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypePrice.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypePolicyPathSelector: FfiConverterRustBuffer {
    typealias SwiftType = PolicyPathSelector?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypePolicyPathSelector.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypePolicyPathSelector.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypePolicyTemplateType: FfiConverterRustBuffer {
    typealias SwiftType = PolicyTemplateType?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypePolicyTemplateType.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypePolicyTemplateType.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionSequenceTypeOutPoint: FfiConverterRustBuffer {
    typealias SwiftType = [OutPoint]?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterSequenceTypeOutPoint.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterSequenceTypeOutPoint.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionDictionaryStringSequenceUInt64: FfiConverterRustBuffer {
    typealias SwiftType = [String: [UInt64]]?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterDictionaryStringSequenceUInt64.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterDictionaryStringSequenceUInt64.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionDictionaryStringSequenceString: FfiConverterRustBuffer {
    typealias SwiftType = [String: [String]]?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterDictionaryStringSequenceString.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterDictionaryStringSequenceString.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeTimestamp: FfiConverterRustBuffer {
    typealias SwiftType = Timestamp?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeTimestamp.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeTimestamp.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterSequenceUInt64: FfiConverterRustBuffer {
    typealias SwiftType = [UInt64]

    public static func write(_ value: [UInt64], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterUInt64.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [UInt64] {
        let len: Int32 = try readInt(&buf)
        var seq = [UInt64]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterUInt64.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceString: FfiConverterRustBuffer {
    typealias SwiftType = [String]

    public static func write(_ value: [String], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterString.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [String] {
        let len: Int32 = try readInt(&buf)
        var seq = [String]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterString.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeDescriptor: FfiConverterRustBuffer {
    typealias SwiftType = [Descriptor]

    public static func write(_ value: [Descriptor], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeDescriptor.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Descriptor] {
        let len: Int32 = try readInt(&buf)
        var seq = [Descriptor]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeDescriptor.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeGetApproval: FfiConverterRustBuffer {
    typealias SwiftType = [GetApproval]

    public static func write(_ value: [GetApproval], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeGetApproval.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [GetApproval] {
        let len: Int32 = try readInt(&buf)
        var seq = [GetApproval]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeGetApproval.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeGetCompletedProposal: FfiConverterRustBuffer {
    typealias SwiftType = [GetCompletedProposal]

    public static func write(_ value: [GetCompletedProposal], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeGetCompletedProposal.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [GetCompletedProposal] {
        let len: Int32 = try readInt(&buf)
        var seq = [GetCompletedProposal]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeGetCompletedProposal.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeGetPolicy: FfiConverterRustBuffer {
    typealias SwiftType = [GetPolicy]

    public static func write(_ value: [GetPolicy], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeGetPolicy.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [GetPolicy] {
        let len: Int32 = try readInt(&buf)
        var seq = [GetPolicy]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeGetPolicy.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeGetProposal: FfiConverterRustBuffer {
    typealias SwiftType = [GetProposal]

    public static func write(_ value: [GetProposal], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeGetProposal.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [GetProposal] {
        let len: Int32 = try readInt(&buf)
        var seq = [GetProposal]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeGetProposal.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeGetSharedSigner: FfiConverterRustBuffer {
    typealias SwiftType = [GetSharedSigner]

    public static func write(_ value: [GetSharedSigner], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeGetSharedSigner.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [GetSharedSigner] {
        let len: Int32 = try readInt(&buf)
        var seq = [GetSharedSigner]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeGetSharedSigner.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeGetSigner: FfiConverterRustBuffer {
    typealias SwiftType = [GetSigner]

    public static func write(_ value: [GetSigner], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeGetSigner.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [GetSigner] {
        let len: Int32 = try readInt(&buf)
        var seq = [GetSigner]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeGetSigner.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeGetTransaction: FfiConverterRustBuffer {
    typealias SwiftType = [GetTransaction]

    public static func write(_ value: [GetTransaction], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeGetTransaction.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [GetTransaction] {
        let len: Int32 = try readInt(&buf)
        var seq = [GetTransaction]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeGetTransaction.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeLocktime: FfiConverterRustBuffer {
    typealias SwiftType = [Locktime]

    public static func write(_ value: [Locktime], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeLocktime.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Locktime] {
        let len: Int32 = try readInt(&buf)
        var seq = [Locktime]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeLocktime.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeNostrConnectRequest: FfiConverterRustBuffer {
    typealias SwiftType = [NostrConnectRequest]

    public static func write(_ value: [NostrConnectRequest], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeNostrConnectRequest.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [NostrConnectRequest] {
        let len: Int32 = try readInt(&buf)
        var seq = [NostrConnectRequest]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeNostrConnectRequest.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeOutPoint: FfiConverterRustBuffer {
    typealias SwiftType = [OutPoint]

    public static func write(_ value: [OutPoint], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeOutPoint.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [OutPoint] {
        let len: Int32 = try readInt(&buf)
        var seq = [OutPoint]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeOutPoint.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeSigner: FfiConverterRustBuffer {
    typealias SwiftType = [Signer]

    public static func write(_ value: [Signer], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeSigner.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Signer] {
        let len: Int32 = try readInt(&buf)
        var seq = [Signer]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeSigner.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeTxIn: FfiConverterRustBuffer {
    typealias SwiftType = [TxIn]

    public static func write(_ value: [TxIn], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeTxIn.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [TxIn] {
        let len: Int32 = try readInt(&buf)
        var seq = [TxIn]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeTxIn.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeTxOut: FfiConverterRustBuffer {
    typealias SwiftType = [TxOut]

    public static func write(_ value: [TxOut], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeTxOut.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [TxOut] {
        let len: Int32 = try readInt(&buf)
        var seq = [TxOut]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeTxOut.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeUtxo: FfiConverterRustBuffer {
    typealias SwiftType = [Utxo]

    public static func write(_ value: [Utxo], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeUtxo.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Utxo] {
        let len: Int32 = try readInt(&buf)
        var seq = [Utxo]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeUtxo.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeKeyAgent: FfiConverterRustBuffer {
    typealias SwiftType = [KeyAgent]

    public static func write(_ value: [KeyAgent], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeKeyAgent.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [KeyAgent] {
        let len: Int32 = try readInt(&buf)
        var seq = [KeyAgent]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeKeyAgent.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeNostrConnectSession: FfiConverterRustBuffer {
    typealias SwiftType = [NostrConnectSession]

    public static func write(_ value: [NostrConnectSession], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeNostrConnectSession.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [NostrConnectSession] {
        let len: Int32 = try readInt(&buf)
        var seq = [NostrConnectSession]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeNostrConnectSession.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypePolicyPathSigner: FfiConverterRustBuffer {
    typealias SwiftType = [PolicyPathSigner]

    public static func write(_ value: [PolicyPathSigner], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypePolicyPathSigner.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [PolicyPathSigner] {
        let len: Int32 = try readInt(&buf)
        var seq = [PolicyPathSigner]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypePolicyPathSigner.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeSignerOffering: FfiConverterRustBuffer {
    typealias SwiftType = [SignerOffering]

    public static func write(_ value: [SignerOffering], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeSignerOffering.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [SignerOffering] {
        let len: Int32 = try readInt(&buf)
        var seq = [SignerOffering]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeSignerOffering.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypePublicKey: FfiConverterRustBuffer {
    typealias SwiftType = [PublicKey]

    public static func write(_ value: [PublicKey], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypePublicKey.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [PublicKey] {
        let len: Int32 = try readInt(&buf)
        var seq = [PublicKey]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypePublicKey.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeProfile: FfiConverterRustBuffer {
    typealias SwiftType = [Profile]

    public static func write(_ value: [Profile], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeProfile.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Profile] {
        let len: Int32 = try readInt(&buf)
        var seq = [Profile]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeProfile.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeRelay: FfiConverterRustBuffer {
    typealias SwiftType = [Relay]

    public static func write(_ value: [Relay], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeRelay.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Relay] {
        let len: Int32 = try readInt(&buf)
        var seq = [Relay]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeRelay.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterDictionaryStringSequenceUInt64: FfiConverterRustBuffer {
    public static func write(_ value: [String: [UInt64]], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterString.write(key, into: &buf)
            FfiConverterSequenceUInt64.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [String: [UInt64]] {
        let len: Int32 = try readInt(&buf)
        var dict = [String: [UInt64]]()
        dict.reserveCapacity(Int(len))
        for _ in 0..<len {
            let key = try FfiConverterString.read(from: &buf)
            let value = try FfiConverterSequenceUInt64.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}

fileprivate struct FfiConverterDictionaryStringSequenceString: FfiConverterRustBuffer {
    public static func write(_ value: [String: [String]], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterString.write(key, into: &buf)
            FfiConverterSequenceString.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [String: [String]] {
        let len: Int32 = try readInt(&buf)
        var dict = [String: [String]]()
        dict.reserveCapacity(Int(len))
        for _ in 0..<len {
            let key = try FfiConverterString.read(from: &buf)
            let value = try FfiConverterSequenceString.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}
















public func getKeychainsList(basePath: String, network: Network) throws  -> [String] {
    return try  FfiConverterSequenceString.lift(
        try rustCallWithError(FfiConverterTypeSmartVaultsError.lift) {
    uniffi_smartvaults_sdk_ffi_fn_func_get_keychains_list(
        FfiConverterString.lower(basePath),
        FfiConverterTypeNetwork.lower(network),$0)
}
    )
}
public func initDesktopLogger(basePath: String, network: Network) throws  {
    try rustCallWithError(FfiConverterTypeSmartVaultsError.lift) {
    uniffi_smartvaults_sdk_ffi_fn_func_init_desktop_logger(
        FfiConverterString.lower(basePath),
        FfiConverterTypeNetwork.lower(network),$0)
}
}


public func initMobileLogger()  {
    try! rustCall() {
    uniffi_smartvaults_sdk_ffi_fn_func_init_mobile_logger($0)
}
}



private enum InitializationResult {
    case ok
    case contractVersionMismatch
    case apiChecksumMismatch
}
// Use a global variables to perform the versioning checks. Swift ensures that
// the code inside is only computed once.
private var initializationResult: InitializationResult {
    // Get the bindings contract version from our ComponentInterface
    let bindings_contract_version = 25
    // Get the scaffolding contract version by calling the into the dylib
    let scaffolding_contract_version = ffi_smartvaults_sdk_ffi_uniffi_contract_version()
    if bindings_contract_version != scaffolding_contract_version {
        return InitializationResult.contractVersionMismatch
    }
    if (uniffi_smartvaults_sdk_ffi_checksum_func_get_keychains_list() != 42545) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_smartvaults_sdk_ffi_checksum_func_init_desktop_logger() != 7048) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_smartvaults_sdk_ffi_checksum_func_init_mobile_logger() != 16576) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_smartvaults_sdk_ffi_checksum_method_aborthandle_abort() != 33620) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_smartvaults_sdk_ffi_checksum_method_aborthandle_is_aborted() != 60948) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_smartvaults_sdk_ffi_checksum_method_balance_confirmed() != 51121) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_smartvaults_sdk_ffi_checksum_method_balance_immature() != 50389) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_smartvaults_sdk_ffi_checksum_method_balance_spendable() != 13085) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_smartvaults_sdk_ffi_checksum_method_balance_total() != 28505) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_smartvaults_sdk_ffi_checksum_method_balance_trusted_pending() != 20931) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_smartvaults_sdk_ffi_checksum_method_balance_untrusted_pending() != 44936) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_smartvaults_sdk_ffi_checksum_method_blocktime_height() != 49396) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_smartvaults_sdk_ffi_checksum_method_blocktime_timestamp() != 26112) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_smartvaults_sdk_ffi_checksum_method_config_block_explorer() != 62975) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_smartvaults_sdk_ffi_checksum_method_config_electrum_endpoint() != 60317) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_smartvaults_sdk_ffi_checksum_method_config_save() != 29504) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_smartvaults_sdk_ffi_checksum_method_config_set_block_explorer() != 12072) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_smartvaults_sdk_ffi_checksum_method_config_set_electrum_endpoint() != 35394) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_smartvaults_sdk_ffi_checksum_method_descriptor_to_str() != 19314) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_smartvaults_sdk_ffi_checksum_method_getaddress_address() != 27521) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_smartvaults_sdk_ffi_checksum_method_getaddress_label() != 9443) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_smartvaults_sdk_ffi_checksum_method_getapproval_approval_id() != 3726) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_smartvaults_sdk_ffi_checksum_method_getapproval_approved_proposal() != 47952) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_smartvaults_sdk_ffi_checksum_method_getapproval_timestamp() != 63276) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_smartvaults_sdk_ffi_checksum_method_getapproval_user() != 3390) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_smartvaults_sdk_ffi_checksum_method_getcompletedproposal_completed_proposal() != 64965) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_smartvaults_sdk_ffi_checksum_method_getcompletedproposal_completed_proposal_id() != 8942) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_smartvaults_sdk_ffi_checksum_method_getcompletedproposal_policy_id() != 21775) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_smartvaults_sdk_ffi_checksum_method_getpolicy_balance() != 36837) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_smartvaults_sdk_ffi_checksum_method_getpolicy_last_sync() != 60174) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_smartvaults_sdk_ffi_checksum_method_getpolicy_policy() != 7518) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_smartvaults_sdk_ffi_checksum_method_getpolicy_policy_id() != 64393) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_smartvaults_sdk_ffi_checksum_method_getproposal_is_signed() != 30267) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_smartvaults_sdk_ffi_checksum_method_getproposal_policy_id() != 37164) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_smartvaults_sdk_ffi_checksum_method_getproposal_proposal() != 8729) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_smartvaults_sdk_ffi_checksum_method_getproposal_proposal_id() != 13989) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_smartvaults_sdk_ffi_checksum_method_getsharedsigner_owner() != 35625) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_smartvaults_sdk_ffi_checksum_method_getsharedsigner_shared_signer() != 23721) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_smartvaults_sdk_ffi_checksum_method_getsharedsigner_shared_signer_id() != 1788) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_smartvaults_sdk_ffi_checksum_method_getsigner_signer() != 27684) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_smartvaults_sdk_ffi_checksum_method_getsigner_signer_id() != 36290) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_smartvaults_sdk_ffi_checksum_method_gettransaction_block_explorer() != 37384) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_smartvaults_sdk_ffi_checksum_method_gettransaction_label() != 53042) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_smartvaults_sdk_ffi_checksum_method_gettransaction_policy_id() != 50032) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_smartvaults_sdk_ffi_checksum_method_gettransaction_tx() != 34653) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_smartvaults_sdk_ffi_checksum_method_nostrconnectrequest_app_public_key() != 12153) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_smartvaults_sdk_ffi_checksum_method_nostrconnectrequest_approved() != 63896) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_smartvaults_sdk_ffi_checksum_method_nostrconnectrequest_event_id() != 30618) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_smartvaults_sdk_ffi_checksum_method_nostrconnectrequest_message() != 41499) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_smartvaults_sdk_ffi_checksum_method_nostrconnectrequest_timestamp() != 47619) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_smartvaults_sdk_ffi_checksum_method_outpoint_txid() != 12301) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_smartvaults_sdk_ffi_checksum_method_outpoint_vout() != 30170) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_smartvaults_sdk_ffi_checksum_method_policy_description() != 38127) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_smartvaults_sdk_ffi_checksum_method_policy_descriptor() != 34834) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_smartvaults_sdk_ffi_checksum_method_policy_get_policy_path_from_signer() != 25302) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_smartvaults_sdk_ffi_checksum_method_policy_get_policy_paths_from_signers() != 29861) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_smartvaults_sdk_ffi_checksum_method_policy_has_timelock() != 42876) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_smartvaults_sdk_ffi_checksum_method_policy_name() != 59731) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_smartvaults_sdk_ffi_checksum_method_policy_satisfiable_item() != 5739) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_smartvaults_sdk_ffi_checksum_method_policy_search_used_signers() != 7062) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_smartvaults_sdk_ffi_checksum_method_policy_selectable_conditions() != 59650) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_smartvaults_sdk_ffi_checksum_method_policy_template_match() != 12666) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_smartvaults_sdk_ffi_checksum_method_price_amount() != 25354) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_smartvaults_sdk_ffi_checksum_method_price_currency() != 45035) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_smartvaults_sdk_ffi_checksum_method_seed_mnemonic() != 56579) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_smartvaults_sdk_ffi_checksum_method_seed_passphrase() != 1349) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_smartvaults_sdk_ffi_checksum_method_sharedsigner_descriptor() != 44995) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_smartvaults_sdk_ffi_checksum_method_sharedsigner_fingerprint() != 20762) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_smartvaults_sdk_ffi_checksum_method_signer_descriptor() != 64725) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_smartvaults_sdk_ffi_checksum_method_signer_display() != 3696) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_smartvaults_sdk_ffi_checksum_method_signer_fingerprint() != 12498) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_smartvaults_sdk_ffi_checksum_method_signer_name() != 32440) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_smartvaults_sdk_ffi_checksum_method_signer_signer_type() != 5403) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_smartvaults_sdk_ffi_checksum_method_smartvaults_add_contact() != 6285) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_smartvaults_sdk_ffi_checksum_method_smartvaults_add_relay() != 60334) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_smartvaults_sdk_ffi_checksum_method_smartvaults_announce_key_agent() != 39254) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_smartvaults_sdk_ffi_checksum_method_smartvaults_approve() != 51534) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_smartvaults_sdk_ffi_checksum_method_smartvaults_approve_nostr_connect_request() != 34137) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_smartvaults_sdk_ffi_checksum_method_smartvaults_approve_with_signed_psbt() != 49556) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_smartvaults_sdk_ffi_checksum_method_smartvaults_auto_approve_nostr_connect_requests() != 37134) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_smartvaults_sdk_ffi_checksum_method_smartvaults_block_height() != 34215) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_smartvaults_sdk_ffi_checksum_method_smartvaults_change_password() != 27785) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_smartvaults_sdk_ffi_checksum_method_smartvaults_check_password() != 26542) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_smartvaults_sdk_ffi_checksum_method_smartvaults_clear_cache() != 54777) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_smartvaults_sdk_ffi_checksum_method_smartvaults_config() != 41120) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_smartvaults_sdk_ffi_checksum_method_smartvaults_deannounce_key_agent() != 64382) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_smartvaults_sdk_ffi_checksum_method_smartvaults_default_relays() != 24993) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_smartvaults_sdk_ffi_checksum_method_smartvaults_delete_completed_proposal_by_id() != 23528) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_smartvaults_sdk_ffi_checksum_method_smartvaults_delete_policy_by_id() != 46643) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_smartvaults_sdk_ffi_checksum_method_smartvaults_delete_proposal_by_id() != 59525) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_smartvaults_sdk_ffi_checksum_method_smartvaults_delete_signer_by_id() != 13151) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_smartvaults_sdk_ffi_checksum_method_smartvaults_disconnect_nostr_connect_session() != 62267) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_smartvaults_sdk_ffi_checksum_method_smartvaults_finalize() != 40010) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_smartvaults_sdk_ffi_checksum_method_smartvaults_get_address() != 36485) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_smartvaults_sdk_ffi_checksum_method_smartvaults_get_all_txs() != 53745) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_smartvaults_sdk_ffi_checksum_method_smartvaults_get_approvals_by_proposal_id() != 20022) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_smartvaults_sdk_ffi_checksum_method_smartvaults_get_balance() != 39048) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_smartvaults_sdk_ffi_checksum_method_smartvaults_get_completed_proposal_by_id() != 8761) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_smartvaults_sdk_ffi_checksum_method_smartvaults_get_completed_proposals() != 21547) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_smartvaults_sdk_ffi_checksum_method_smartvaults_get_contacts() != 39478) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_smartvaults_sdk_ffi_checksum_method_smartvaults_get_last_unused_address() != 23411) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_smartvaults_sdk_ffi_checksum_method_smartvaults_get_members_of_policy() != 2139) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_smartvaults_sdk_ffi_checksum_method_smartvaults_get_nostr_connect_requests() != 7471) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_smartvaults_sdk_ffi_checksum_method_smartvaults_get_nostr_connect_sessions() != 41568) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_smartvaults_sdk_ffi_checksum_method_smartvaults_get_policies() != 5694) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_smartvaults_sdk_ffi_checksum_method_smartvaults_get_policy_by_id() != 15881) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_smartvaults_sdk_ffi_checksum_method_smartvaults_get_profile() != 60761) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_smartvaults_sdk_ffi_checksum_method_smartvaults_get_proposal_by_id() != 41324) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_smartvaults_sdk_ffi_checksum_method_smartvaults_get_proposals() != 31235) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_smartvaults_sdk_ffi_checksum_method_smartvaults_get_proposals_by_policy_id() != 24582) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_smartvaults_sdk_ffi_checksum_method_smartvaults_get_public_key_metadata() != 59304) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_smartvaults_sdk_ffi_checksum_method_smartvaults_get_shared_signers() != 52112) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_smartvaults_sdk_ffi_checksum_method_smartvaults_get_shared_signers_by_public_key() != 62748) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_smartvaults_sdk_ffi_checksum_method_smartvaults_get_shared_signers_public_keys() != 64122) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_smartvaults_sdk_ffi_checksum_method_smartvaults_get_signer_by_id() != 29794) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_smartvaults_sdk_ffi_checksum_method_smartvaults_get_signers() != 23241) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_smartvaults_sdk_ffi_checksum_method_smartvaults_get_total_balance() != 40541) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_smartvaults_sdk_ffi_checksum_method_smartvaults_get_tx() != 49519) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_smartvaults_sdk_ffi_checksum_method_smartvaults_get_txs() != 25194) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_smartvaults_sdk_ffi_checksum_method_smartvaults_get_utxos() != 25313) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_smartvaults_sdk_ffi_checksum_method_smartvaults_handle_sync() != 34320) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_smartvaults_sdk_ffi_checksum_method_smartvaults_key_agent_payment() != 46828) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_smartvaults_sdk_ffi_checksum_method_smartvaults_key_agents() != 13830) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_smartvaults_sdk_ffi_checksum_method_smartvaults_keys() != 36850) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_smartvaults_sdk_ffi_checksum_method_smartvaults_name() != 61686) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_smartvaults_sdk_ffi_checksum_method_smartvaults_network() != 36013) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_smartvaults_sdk_ffi_checksum_method_smartvaults_new_nostr_connect_session() != 326) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_smartvaults_sdk_ffi_checksum_method_smartvaults_new_proof_proposal() != 59288) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_smartvaults_sdk_ffi_checksum_method_smartvaults_rebroadcast_all_events() != 26947) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_smartvaults_sdk_ffi_checksum_method_smartvaults_reject_nostr_connect_request() != 64099) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_smartvaults_sdk_ffi_checksum_method_smartvaults_relays() != 35651) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_smartvaults_sdk_ffi_checksum_method_smartvaults_remove_contact() != 9276) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_smartvaults_sdk_ffi_checksum_method_smartvaults_remove_relay() != 30109) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_smartvaults_sdk_ffi_checksum_method_smartvaults_rename() != 44888) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_smartvaults_sdk_ffi_checksum_method_smartvaults_republish_shared_key_for_policy() != 46910) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_smartvaults_sdk_ffi_checksum_method_smartvaults_request_signers_to_key_agent() != 7675) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_smartvaults_sdk_ffi_checksum_method_smartvaults_revoke_all_shared_signers() != 60084) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_smartvaults_sdk_ffi_checksum_method_smartvaults_revoke_approval() != 35678) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_smartvaults_sdk_ffi_checksum_method_smartvaults_revoke_shared_signer() != 4082) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_smartvaults_sdk_ffi_checksum_method_smartvaults_save_policy() != 1415) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_smartvaults_sdk_ffi_checksum_method_smartvaults_save_policy_from_template() != 2455) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_smartvaults_sdk_ffi_checksum_method_smartvaults_save_smartvaults_signer() != 47462) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_smartvaults_sdk_ffi_checksum_method_smartvaults_seed() != 57162) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_smartvaults_sdk_ffi_checksum_method_smartvaults_self_transfer() != 64764) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_smartvaults_sdk_ffi_checksum_method_smartvaults_set_metadata() != 64985) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_smartvaults_sdk_ffi_checksum_method_smartvaults_share_signer() != 14056) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_smartvaults_sdk_ffi_checksum_method_smartvaults_share_signer_to_multiple_public_keys() != 678) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_smartvaults_sdk_ffi_checksum_method_smartvaults_shutdown() != 5765) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_smartvaults_sdk_ffi_checksum_method_smartvaults_signer_offering() != 51288) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_smartvaults_sdk_ffi_checksum_method_smartvaults_smartvaults_signer_exists() != 16365) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_smartvaults_sdk_ffi_checksum_method_smartvaults_spend() != 29187) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_smartvaults_sdk_ffi_checksum_method_smartvaults_start() != 25793) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_smartvaults_sdk_ffi_checksum_method_smartvaults_stop() != 30535) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_smartvaults_sdk_ffi_checksum_method_smartvaults_wipe() != 15069) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_smartvaults_sdk_ffi_checksum_method_smartvaultslibrary_git_hash_version() != 59880) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_smartvaults_sdk_ffi_checksum_method_transaction_inputs() != 40874) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_smartvaults_sdk_ffi_checksum_method_transaction_is_explicitly_rbf() != 61967) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_smartvaults_sdk_ffi_checksum_method_transaction_is_lock_time_enabled() != 12085) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_smartvaults_sdk_ffi_checksum_method_transaction_lock_time() != 26875) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_smartvaults_sdk_ffi_checksum_method_transaction_outputs() != 12948) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_smartvaults_sdk_ffi_checksum_method_transaction_size() != 40502) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_smartvaults_sdk_ffi_checksum_method_transaction_txid() != 49890) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_smartvaults_sdk_ffi_checksum_method_transaction_version() != 18374) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_smartvaults_sdk_ffi_checksum_method_transaction_vsize() != 40075) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_smartvaults_sdk_ffi_checksum_method_transaction_weight() != 23288) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_smartvaults_sdk_ffi_checksum_method_transactiondetails_confirmation_time() != 1940) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_smartvaults_sdk_ffi_checksum_method_transactiondetails_fee() != 44947) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_smartvaults_sdk_ffi_checksum_method_transactiondetails_received() != 37680) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_smartvaults_sdk_ffi_checksum_method_transactiondetails_sent() != 63893) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_smartvaults_sdk_ffi_checksum_method_transactiondetails_total() != 18671) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_smartvaults_sdk_ffi_checksum_method_transactiondetails_transaction() != 28901) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_smartvaults_sdk_ffi_checksum_method_transactiondetails_txid() != 12825) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_smartvaults_sdk_ffi_checksum_method_txin_previous_output() != 33592) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_smartvaults_sdk_ffi_checksum_method_txout_address() != 64604) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_smartvaults_sdk_ffi_checksum_method_txout_value() != 35271) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_smartvaults_sdk_ffi_checksum_method_utxo_is_spent() != 48373) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_smartvaults_sdk_ffi_checksum_method_utxo_label() != 10857) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_smartvaults_sdk_ffi_checksum_method_utxo_outpoint() != 13314) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_smartvaults_sdk_ffi_checksum_method_utxo_value() != 41279) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_smartvaults_sdk_ffi_checksum_constructor_absolutelocktime_from_height() != 55543) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_smartvaults_sdk_ffi_checksum_constructor_absolutelocktime_from_timestamp() != 50028) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_smartvaults_sdk_ffi_checksum_constructor_amount_custom() != 26876) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_smartvaults_sdk_ffi_checksum_constructor_amount_max() != 14286) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_smartvaults_sdk_ffi_checksum_constructor_decayingtime_multiple() != 29504) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_smartvaults_sdk_ffi_checksum_constructor_decayingtime_single() != 16087) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_smartvaults_sdk_ffi_checksum_constructor_descriptor_parse() != 2070) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_smartvaults_sdk_ffi_checksum_constructor_locktime_absolute() != 47155) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_smartvaults_sdk_ffi_checksum_constructor_locktime_relative() != 42614) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_smartvaults_sdk_ffi_checksum_constructor_policytemplate_decaying() != 5204) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_smartvaults_sdk_ffi_checksum_constructor_policytemplate_hold() != 48778) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_smartvaults_sdk_ffi_checksum_constructor_policytemplate_multisig() != 54982) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_smartvaults_sdk_ffi_checksum_constructor_policytemplate_recovery() != 4509) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_smartvaults_sdk_ffi_checksum_constructor_price_new() != 47537) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_smartvaults_sdk_ffi_checksum_constructor_recoverytemplate_new() != 10437) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_smartvaults_sdk_ffi_checksum_constructor_relativelocktime_from_blocks() != 39675) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_smartvaults_sdk_ffi_checksum_constructor_smartvaults_generate() != 35324) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_smartvaults_sdk_ffi_checksum_constructor_smartvaults_open() != 47272) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_smartvaults_sdk_ffi_checksum_constructor_smartvaults_restore() != 5876) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_smartvaults_sdk_ffi_checksum_constructor_smartvaultslibrary_new() != 3404) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_smartvaults_sdk_ffi_checksum_method_synchandler_handle() != 17491) {
        return InitializationResult.apiChecksumMismatch
    }

    uniffiCallbackInitSyncHandler()
    return InitializationResult.ok
}

private func uniffiEnsureInitialized() {
    switch initializationResult {
    case .ok:
        break
    case .contractVersionMismatch:
        fatalError("UniFFI contract version mismatch: try cleaning and rebuilding your project")
    case .apiChecksumMismatch:
        fatalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
}